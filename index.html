<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kindle Review Meter (Complete Edition)</title>
  <!-- Cache buster: 2025-08-08-17:48 - Force reload -->
  <style>
    /* Modern CSS Variables */
    :root {
      /* Modern Color Palette */
      --bg-primary: linear-gradient(135deg, #0ea5e9 0%, #22d3ee 100%);
      --bg-secondary: #fafbfc;
      --fg-primary: #1a202c;
      --fg-secondary: #4a5568;
      --fg-muted: #718096;
      
      /* Brand Colors */
      --primary: linear-gradient(135deg, #3b82f6, #06b6d4);
      --primary-solid: #3b82f6;
      --accent: linear-gradient(135deg, #f43f5e, #fb7185);
      --accent-solid: #f43f5e;
      --warning: #fbbf24;
      --danger: #ef4444;
      --success: #10b981;
      --info: #3b82f6;
      
      /* Surface Colors */
      --surface: rgba(255, 255, 255, 0.95);
      --surface-elevated: rgba(255, 255, 255, 0.98);
      --glass: rgba(255, 255, 255, 0.25);
      --glass-border: rgba(255, 255, 255, 0.2);
      
      /* Borders & Effects */
      --border: rgba(226, 232, 240, 0.8);
      --border-light: #f1f5f9;
      --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.08);
      --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.1);
      --shadow-lg: 0 8px 25px rgba(0, 0, 0, 0.12);
      --shadow-xl: 0 20px 40px rgba(0, 0, 0, 0.15);
      --shadow-glass: 0 8px 32px rgba(31, 38, 135, 0.37);
      
      /* Spacing System */
      --space-xs: 0.25rem;
      --space-sm: 0.5rem;
      --space-md: 1rem;
      --space-lg: 1.5rem;
      --space-xl: 2rem;
      --space-2xl: 3rem;
      
      /* Border Radius */
      --radius-sm: 0.5rem;
      --radius-md: 0.75rem;
      --radius-lg: 1rem;
      --radius-xl: 1.5rem;
      --radius-2xl: 2rem;
      
      /* Transitions & Animation */
      --transition-fast: 0.15s cubic-bezier(0.4, 0, 0.2, 1);
      --transition-normal: 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      --transition-slow: 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      --transition-spring: 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      --transition-bounce: 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      --animation-duration: 0.6s;
    }

    /* Global Styles */
    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      color: var(--fg-primary);
      line-height: 1.6;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    body {
      min-height: 100vh;
      background: var(--bg-primary);
      position: relative;
    }

    /* Background Pattern */
    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background-image: 
        radial-gradient(circle at 25% 25%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 75% 75%, rgba(255, 255, 255, 0.05) 0%, transparent 50%);
      pointer-events: none;
      z-index: 1;
    }

    /* Header with Glassmorphism */
    .header {
      position: sticky;
      top: 0;
      z-index: 100;
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      background: var(--glass);
      border-bottom: 1px solid var(--glass-border);
      padding: var(--space-lg) 0;
      margin-bottom: var(--space-xl);
    }
    
    .header-content {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 var(--space-xl);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .header h1 {
      margin: 0;
      font-size: 1.75rem;
      font-weight: 800;
      background: linear-gradient(135deg, #ffffff, #f1f5f9);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .tabs {
      display: flex;
      gap: var(--space-sm);
      background: rgba(255, 255, 255, 0.1);
      padding: var(--space-xs);
      border-radius: var(--radius-2xl);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid var(--glass-border);
    }
    
    .tab {
      padding: var(--space-md) var(--space-lg);
      background: transparent;
      border: none;
      border-radius: var(--radius-xl);
      color: rgba(255, 255, 255, 0.8);
      cursor: pointer;
      font-weight: 600;
      font-size: 0.9rem;
      transition: all var(--transition-normal);
      position: relative;
      overflow: hidden;
    }
    
    .tab::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
      opacity: 0;
      transition: opacity var(--transition-normal);
    }
    
    .tab:hover::before {
      opacity: 1;
    }
    
    .tab.active {
      color: white;
      background: rgba(255, 255, 255, 0.2);
      box-shadow: var(--shadow-md);
      transform: translateY(-1px);
    }

    /* Main Container */
    .main-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 var(--space-xl);
      position: relative;
      z-index: 2;
    }
    
    .view {
      display: none;
      opacity: 0;
      transform: translateY(30px);
      transition: all var(--transition-slow);
    }
    
    .view.active {
      display: block;
      opacity: 1;
      transform: translateY(0);
    }
    
    /* Glassmorphism Cards */
    .card {
      background: var(--surface);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--border);
      border-radius: var(--radius-2xl);
      padding: var(--space-2xl);
      margin-bottom: var(--space-xl);
      box-shadow: var(--shadow-glass);
      transition: all var(--transition-normal);
      position: relative;
      overflow: hidden;
    }
    
    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: var(--primary);
      opacity: 0;
      transition: opacity var(--transition-normal);
    }
    
    .card:hover {
      transform: translateY(-8px);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
    }
    
    .card:hover::before {
      opacity: 1;
    }
    
    .card h2 {
      margin: 0 0 var(--space-xl) 0;
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--fg-primary);
      display: flex;
      align-items: center;
      gap: var(--space-md);
    }
    
    /* Form Styles */
    .form-grid {
      display: grid;
      gap: var(--space-lg);
    }
    
    .form-group {
      position: relative;
    }
    
    .form-group label {
      display: block;
      margin-bottom: var(--space-sm);
      font-weight: 600;
      color: var(--fg-primary);
      font-size: 0.9rem;
      letter-spacing: 0.01em;
    }
    
    .form-group input {
      width: 100%;
      padding: var(--space-lg);
      border: 2px solid var(--border);
      border-radius: var(--radius-lg);
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(10px);
      font-size: 1rem;
      transition: all var(--transition-normal);
      font-family: inherit;
    }
    
    .form-group input:focus {
      outline: none;
      border-color: var(--primary-solid);
      background: rgba(255, 255, 255, 0.95);
      box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.1);
      transform: translateY(-2px);
    }
    
    .form-group input::placeholder {
      color: var(--fg-muted);
      opacity: 0.7;
    }

    /* Flex input group for URL + button */
    .input-group {
      display: flex;
      gap: var(--space-md);
    }

    .input-group input {
      flex: 1;
    }

    .input-group .btn {
      flex-shrink: 0;
      margin: 0;
    }
    
    /* Button System */
    .btn-group {
      display: flex;
      gap: var(--space-md);
      flex-wrap: wrap;
      margin-top: var(--space-xl);
    }
    
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-sm);
      padding: var(--space-lg) var(--space-xl);
      border: 2px solid transparent;
      border-radius: var(--radius-lg);
      font-size: 0.9rem;
      font-weight: 600;
      text-decoration: none;
      cursor: pointer;
      transition: all var(--transition-normal);
      position: relative;
      overflow: hidden;
      min-height: 48px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    
    .btn::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, transparent, rgba(255, 255, 255, 0.1));
      opacity: 0;
      transition: opacity var(--transition-fast);
    }
    
    .btn:hover::before {
      opacity: 1;
    }
    
    .btn:hover {
      transform: translateY(-3px) scale(1.02);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
      animation: none;
    }
    
    .btn:active {
      transform: translateY(-1px) scale(0.98);
      transition: all var(--transition-fast);
    }
    
    .btn.primary {
      background: var(--primary);
      color: white;
      box-shadow: var(--shadow-md);
    }
    
    .btn.secondary {
      background: rgba(255, 255, 255, 0.9);
      color: var(--fg-primary);
      border-color: var(--border);
    }
    
    .btn.secondary:hover {
      background: rgba(255, 255, 255, 1);
      border-color: var(--primary-solid);
    }
    
    .btn.danger {
      background: linear-gradient(135deg, var(--danger), #dc2626);
      color: white;
    }

    /* Loading States */
    .btn.loading {
      pointer-events: none;
      position: relative;
      color: transparent;
    }

    .btn.loading::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: translate(-50%, -50%) rotate(360deg);
      }
    }
    
    /* Progress Display - 3:4 Vertical Layout */
    .progress-display.vertical {
      display: flex;
      flex-direction: column;
      width: 420px; /* 3:4 ratio base - 420px width */
      height: 560px; /* 3:4 ratio base - 560px height (420*4/3) */
      margin: 0 auto;
      padding: var(--space-lg);
      background: 
        rgba(255, 255, 255, 0.05),
        radial-gradient(circle at 20% 20%, rgba(14, 165, 233, 0.05) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(34, 211, 238, 0.05) 0%, transparent 50%);
      border-radius: var(--radius-xl);
      backdrop-filter: blur(10px);
      gap: var(--space-sm);
      position: relative;
      overflow: visible;
    }

    .progress-display.vertical::before {
      content: '';
      position: absolute;
      top: 15px;
      right: 15px;
      width: 12px;
      height: 12px;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.2), transparent);
      border-radius: 50%;
    }
    
    /* Book Cover Section - Top Center */
    .book-cover-section {
      display: flex;
      justify-content: center;
      margin-bottom: var(--space-md);
    }
    
    .book-cover {
      flex-shrink: 0;
    }
    
    .book-cover img {
      width: 120px;
      height: 180px;
      object-fit: cover;
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-xl), 0 0 20px rgba(139, 92, 246, 0.1);
      transition: all var(--transition-normal);
      border: 3px solid rgba(255, 255, 255, 0.2);
      position: relative;
    }
    
    .book-cover img:hover {
      transform: scale(1.02) rotateY(2deg);
      box-shadow: 0 25px 50px rgba(0, 0, 0, 0.25), 0 0 30px rgba(139, 92, 246, 0.2);
    }
    
    .book-cover .no-image {
      width: 120px;
      height: 180px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
      border: 2px dashed rgba(255, 255, 255, 0.3);
      border-radius: var(--radius-lg);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      color: rgba(255, 255, 255, 0.7);
      font-size: 12px;
      text-align: center;
      backdrop-filter: blur(10px);
    }

    /* Book Meta - Small Title and Author */
    .book-meta {
      text-align: center;
      margin-bottom: var(--space-xs);
      width: 100%;
      max-width: 380px;
      margin-left: auto;
      margin-right: auto;
    }

    .book-title {
      font-size: 0.95rem;
      font-weight: 600;
      color: #1a202c;
      margin: 0 0 var(--space-xs) 0;
      line-height: 1.3;
      max-width: 220px; /* tighten to avoid rim */
      word-wrap: break-word;
      overflow-wrap: anywhere; /* allow earlier wrapping for long CJK */
      hyphens: auto;
      white-space: normal;
      text-align: center;
      padding: 0 32px; /* doubled inner padding */
      margin-left: auto;
      margin-right: auto;
    }

    .book-author {
      font-size: 0.8rem;
      color: #4a5568;
      margin: 0;
      font-weight: 400;
      max-width: 220px; /* sync with title width */
      word-wrap: break-word;
      overflow-wrap: anywhere;
      text-align: center;
      padding: 0 32px; /* doubled inner padding */
      margin-left: auto;
      margin-right: auto;
    }

    /* Current Reviews Highlight - Main Focus */
    .current-reviews-highlight {
      text-align: center;
      margin: var(--space-md) 0 0 0;
      padding: var(--space-md) 0;
      position: relative;
    }


    .current-number {
      font-size: 3.5rem; /* 少し大きく */
      font-weight: 800;
      background: linear-gradient(135deg, #3b82f6, #06b6d4, #10b981);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow:
        0 2px 8px rgba(14, 165, 233, 0.28),
        0 0 18px rgba(14, 165, 233, 0.22); /* 後光感を強化 */
      line-height: 1;
      margin-bottom: var(--space-sm);
      position: relative;
      z-index: 1;
      filter: drop-shadow(0 0 18px rgba(14, 165, 233, 0.25));
    }

    .current-label {
      font-size: 0.85rem;
      color: #4a5568;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* Progress Section */
    .progress-section {
      margin-top: 0;
    }

    .progress-stats {
      display: flex;
      justify-content: space-between;
      gap: var(--space-md);
      margin-top: var(--space-md);
    }

    .target-info, .remaining-info {
      flex: 1;
      text-align: center;
      padding: var(--space-sm) var(--space-md);
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.08));
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: var(--radius-lg);
      backdrop-filter: blur(10px);
      font-size: 0.8rem;
      color: #374151;
      font-weight: 500;
      transition: all var(--transition-fast);
      position: relative;
      overflow: hidden;
      box-shadow: var(--shadow-md), 0 0 12px rgba(139, 92, 246, 0.15);
    }

    .target-info::before, .remaining-info::before {
      content: '';
      position: absolute;
      top: 6px;
      right: 8px;
      width: 4px;
      height: 4px;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 50%;
    }

    .target-info:hover, .remaining-info:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg), 0 0 16px rgba(139, 92, 246, 0.2);
    }
    
    .book-info {
      flex: 1;
    }
    
    .book-info h3 {
      margin: 0 0 var(--space-md) 0;
      font-size: 1.75rem;
      font-weight: 800;
      color: var(--fg-primary);
      line-height: 1.2;
    }
    
    .book-info .author,
    .book-info .target {
      margin: var(--space-sm) 0;
      color: var(--fg-secondary);
      font-size: 1rem;
    }
    
    /* Modern Progress Bar */
    .progress-bar {
      background: rgba(255, 255, 255, 0.2);
      height: 32px;
      border-radius: var(--radius-2xl);
      overflow: hidden;
      margin: var(--space-xl) 0;
      position: relative;
      backdrop-filter: blur(10px);
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(135deg, #3b82f6, #06b6d4, #10b981) !important;
      border-radius: var(--radius-2xl);
      transition: width var(--transition-slow) ease-out;
      position: relative;
      min-width: 2px;
      box-shadow: 0 2px 8px rgba(14, 165, 233, 0.35), 0 0 16px rgba(14, 165, 233, 0.2);
      overflow: hidden;
    }

    .progress-fill::after {
      content: '';
      position: absolute;
      top: 2px;
      right: 8px;
      width: 20px;
      height: 20px;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.8), transparent);
      border-radius: 50%;
      opacity: 0.7;
    }

    /* stripes removed for simpler, clean look */
    
    .progress-text {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      color: #1a202c; /* 視認性向上のため濃色 */
      font-weight: 800;
      font-size: 1rem;
      text-shadow: 0 1px 0 rgba(255, 255, 255, 0.6);
      z-index: 2;
    }
    
    /* Statistics Grid */
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: var(--space-lg);
      margin: var(--space-2xl) 0;
    }
    
    .stat {
      background: var(--surface-elevated);
      backdrop-filter: blur(20px);
      padding: var(--space-xl);
      border-radius: var(--radius-xl);
      text-align: center;
      border: 1px solid var(--border);
      transition: all var(--transition-normal);
      position: relative;
      overflow: hidden;
    }
    
    .stat::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: var(--accent);
    }
    
    .stat:hover {
      transform: translateY(-4px);
      box-shadow: var(--shadow-lg);
    }
    
    .stat-value {
      font-size: 2.5rem;
      font-weight: 900;
      background: var(--primary);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: var(--space-sm);
      display: block;
    }
    
    .stat-label {
      color: var(--fg-muted);
      font-size: 0.875rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .milestone {
      text-align: center;
      font-size: 1.25rem;
      font-weight: 700;
      margin-top: var(--space-xl);
      padding: var(--space-lg);
      background: rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-lg);
      backdrop-filter: blur(10px);
    }

    /* Animations */
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes pulse {
      0% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.05);
      }
      100% {
        transform: scale(1);
      }
    }

    @keyframes wiggle {
      0%, 7% {
        transform: rotateZ(0);
      }
      15% {
        transform: rotateZ(-15deg);
      }
      20% {
        transform: rotateZ(10deg);
      }
      25% {
        transform: rotateZ(-10deg);
      }
      30% {
        transform: rotateZ(6deg);
      }
      35% {
        transform: rotateZ(-4deg);
      }
      40%, 100% {
        transform: rotateZ(0);
      }
    }

    .animate-wiggle {
      animation: wiggle 0.8s var(--transition-normal);
    }

    .animate-pulse {
      animation: pulse 0.5s var(--transition-normal);
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .header-content {
        flex-direction: column;
        gap: var(--space-lg);
      }
      
      .main-container {
        padding: 0 var(--space-lg);
      }
      
      .card {
        padding: var(--space-xl);
      }
      
      .progress-display.vertical {
        width: 350px;
        height: 467px; /* 350*4/3 */
        padding: var(--space-lg); /* add inner safe space on mobile */
      }

      .book-title {
        font-size: 0.9rem;
        max-width: 200px;
        margin-left: auto;
        margin-right: auto;
        overflow-wrap: anywhere;
        padding: 0 32px; /* doubled on mobile too */
      }

      .book-author {
        font-size: 0.75rem;
        max-width: 200px;
        margin-left: auto;
        margin-right: auto;
        overflow-wrap: anywhere;
        padding: 0 32px; /* doubled on mobile too */
      }
      
      .book-cover img,
      .book-cover .no-image {
        width: 100px;
        height: 150px;
      }
      
      .current-number {
        font-size: 2.5rem;
      }
      
      .book-cover img,
      .book-cover .no-image {
        width: 120px;
        height: 180px;
      }
      
      .btn-group {
        flex-direction: column;
      }
      
      .stats {
        grid-template-columns: 1fr;
        gap: var(--space-md);
      }

      .input-group {
        flex-direction: column;
      }

      .input-group .btn {
        flex: none;
      }
    }

    /* Toast System */
    .toast-container {
      position: fixed;
      top: 120px; /* Below header and tabs */
      right: var(--space-xl);
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
      z-index: 1000;
      pointer-events: none;
    }

    @media (max-width: 640px) {
      .toast-container {
        top: 140px; /* Extra space for mobile stacked header */
        right: var(--space-lg);
        left: var(--space-lg);
      }
    }

    .toast {
      min-width: 280px;
      max-width: 320px;
      background: var(--surface);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-md);
      opacity: 0;
      transform: translateX(400px);
      transition: all var(--transition-normal) cubic-bezier(0.4, 0, 0.2, 1);
      pointer-events: auto;
      position: relative;
    }

    .toast.show {
      opacity: 1;
      transform: translateX(0);
    }

    .toast.removing {
      opacity: 0;
      transform: translateX(400px);
      max-height: 0;
      margin-bottom: 0;
    }

    .toast-content {
      display: flex;
      align-items: flex-start;
      padding: var(--space-md) var(--space-lg);
      gap: var(--space-sm);
    }

    .toast-icon {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
      flex-shrink: 0;
    }

    .toast-success .toast-icon {
      background: rgba(16, 185, 129, 0.1);
      color: var(--success);
    }

    .toast-warning .toast-icon {
      background: rgba(251, 191, 36, 0.1);
      color: var(--warning);
    }

    .toast-error .toast-icon {
      background: rgba(239, 68, 68, 0.1);
      color: var(--danger);
    }

    .toast-info .toast-icon {
      background: rgba(59, 130, 246, 0.1);
      color: var(--info);
    }

    .toast-body {
      flex: 1;
    }

    .toast-title {
      font-weight: 700;
      color: var(--fg-primary);
      font-size: 0.8rem;
      margin-bottom: var(--space-xs);
    }

    .toast-message {
      color: var(--fg-secondary);
      font-size: 0.75rem;
      line-height: 1.4;
    }

    .toast-close {
      background: transparent;
      border: none;
      color: var(--fg-muted);
      cursor: pointer;
      padding: var(--space-xs);
      border-radius: var(--radius-sm);
      transition: all var(--transition-fast);
      font-size: 18px;
      line-height: 1;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .toast-close:hover {
      background: var(--border-light);
      color: var(--fg-primary);
    }

    @media (max-width: 640px) {
      .toast {
        min-width: auto;
        max-width: none;
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="header-content">
      <h1>📚 Kindle Review Meter</h1>
    </div>
  </div>

  <div class="main-container">
    <div id="view-settings" class="view active">
      <div class="card">
        <h2>🖼️ 共有画像作成</h2>
        
        <div class="form-grid">
          <div class="form-group">
            <label for="amazonUrl">Amazon書籍URL</label>
            <div class="input-group">
              <input type="url" id="amazonUrl" placeholder="https://www.amazon.co.jp/dp/...">
              <button type="button" class="btn primary" onclick="app.fetchAmazonData()">
                🔍 自動取得
              </button>
            </div>
          </div>
          
          <div class="form-group">
            <label for="title">書籍タイトル</label>
            <input type="text" id="title" placeholder="書籍タイトル">
          </div>
          
          <div class="form-group">
            <label for="author">著者名</label>
            <input type="text" id="author" placeholder="著者名">
          </div>
          
          <div class="form-group">
            <label for="imageUrl">書影URL（任意）</label>
            <input type="url" id="imageUrl" placeholder="https://m.media-amazon.com/images/I/...">
          </div>
          
          <div class="form-group">
            <label for="reviewCount">現在のレビュー数</label>
            <input type="number" id="reviewCount" min="0" value="0">
          </div>
          
          <div class="form-group">
            <label for="targetReviews">目標レビュー数</label>
            <input type="number" id="targetReviews" min="1" placeholder="目標値（数値）を設定すると進捗バーが出現します">
          </div>
        </div>
        
        <div class="btn-group">
          <button class="btn primary" onclick="app.saveData()">💾 保存</button>
          <button class="btn secondary" onclick="app.clearData()">🗑️ クリア</button>
          <button class="btn primary" onclick="app.exportProgressImage()">🖼️ 画像シェア</button>
        </div>
      </div>
    </div>

    
  </div>

  <!-- Toast Container -->
  <div class="toast-container" id="toast-container"></div>

  <script>
    // Storage Service (Inline)
    class StorageService {
      constructor(key = 'kindleReviewMeter') {
        this.storageKey = key;
      }

      save(data) {
        try {
          localStorage.setItem(this.storageKey, JSON.stringify(data));
          return true;
        } catch (error) {
          console.error('Storage save failed:', error);
          return false;
        }
      }

      load() {
        try {
          const data = localStorage.getItem(this.storageKey);
          return data ? JSON.parse(data) : null;
        } catch (error) {
          console.error('Storage load failed:', error);
          return null;
        }
      }

      clear() {
        try {
          localStorage.removeItem(this.storageKey);
          return true;
        } catch (error) {
          console.error('Storage clear failed:', error);
          return false;
        }
      }
    }

    // Toast Service (Inline)
    class ToastService {
      constructor() {
        this.container = null;
        this.toasts = [];
        this.init();
      }

      init() {
        this.container = document.getElementById('toast-container');
      }

      show(message, type = 'info', options = {}) {
        const {
          title = this.getDefaultTitle(type),
          duration = 4000,
          closable = true
        } = options;

        const toast = this.createToast(message, type, title, closable);
        this.container.appendChild(toast);
        
        this.toasts.push(toast);
        
        requestAnimationFrame(() => {
          toast.classList.add('show');
        });

        if (duration > 0) {
          setTimeout(() => {
            this.dismiss(toast);
          }, duration);
        }

        return toast;
      }

      createToast(message, type, title, closable) {
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;

        const icon = this.getIcon(type);
        
        toast.innerHTML = `
          <div class="toast-content">
            <div class="toast-icon">${icon}</div>
            <div class="toast-body">
              <div class="toast-title">${title}</div>
              <div class="toast-message">${message}</div>
            </div>
            ${closable ? '<button class="toast-close" aria-label="Close">×</button>' : ''}
          </div>
        `;

        if (closable) {
          const closeBtn = toast.querySelector('.toast-close');
          closeBtn.addEventListener('click', () => this.dismiss(toast));
        }

        return toast;
      }

      dismiss(toast) {
        if (!toast || !toast.parentNode) return;

        const index = this.toasts.indexOf(toast);
        if (index > -1) {
          this.toasts.splice(index, 1);
        }

        toast.classList.add('removing');
        
        setTimeout(() => {
          if (toast.parentNode) {
            toast.parentNode.removeChild(toast);
          }
        }, 300);
      }

      getDefaultTitle(type) {
        const titles = {
          success: '成功',
          error: 'エラー',
          warning: '警告',
          info: '情報'
        };
        return titles[type] || '通知';
      }

      getIcon(type) {
        const icons = {
          success: '✓',
          error: '✕',
          warning: '⚠',
          info: 'ℹ'
        };
        return icons[type] || 'ℹ';
      }

      success(message, options = {}) {
        return this.show(message, 'success', options);
      }

      error(message, options = {}) {
        return this.show(message, 'error', options);
      }

      warning(message, options = {}) {
        return this.show(message, 'warning', options);
      }

      info(message, options = {}) {
        return this.show(message, 'info', options);
      }
    }

    // Main App Class
    class App {
      constructor() {
        this.storage = new StorageService();
        this.toast = new ToastService();
        this.currentTab = 'settings';
        this.init();
      }

      init() {
        this.bindEvents();
        this.loadData();
        
        setTimeout(() => {
          this.toast.info('完全版Kindle Review Meter へようこそ！', {
            title: 'ようこそ',
            duration: 6000
          });
        }, 800);
      }

      bindEvents() {
        document.querySelectorAll('.tab').forEach(tab => {
          tab.addEventListener('click', (e) => {
            this.switchTab(e.target.dataset.tab);
          });
        });
      }

      switchTab(tabName) {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
        
        document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
        
        setTimeout(() => {
          document.getElementById(`view-${tabName}`).classList.add('active');
        }, 100);
        
        this.currentTab = tabName;
        
        if (tabName === 'progress') {
          this.showProgress();
        }
      }

      async fetchAmazonData() {
        const urlInput = document.getElementById('amazonUrl');
        const fetchBtn = event?.target;
        const url = urlInput.value.trim();

        if (!url) {
          this.toast.warning('Amazon URLを入力してください', {
            title: '入力が必要です'
          });
          this.animateInputError('amazonUrl');
          return;
        }

        if (!this.isValidAmazonUrl(url)) {
          this.toast.error('有効なAmazon書籍URLを入力してください', {
            title: 'URL形式エラー'
          });
          this.animateInputError('amazonUrl');
          return;
        }

        if (fetchBtn) {
          fetchBtn.classList.add('loading');
          fetchBtn.disabled = true;
        }

        try {
          this.toast.info('Amazon商品ページから情報を取得中...', {
            title: 'データ取得中',
            duration: 3000
          });

          const bookData = await this.scrapeAmazonData(url);
          
          if (bookData) {
            this.populateBookData(bookData);
            this.toast.success(`「${bookData.title}」の情報を取得しました`, {
              title: '取得完了',
              duration: 5000
            });
          } else {
            this.toast.warning('書籍情報の取得に失敗しました。CORSプロキシが利用できない可能性があります。', {
              title: '取得失敗',
              duration: 8000
            });
          }
        } catch (error) {
          console.error('Amazon data fetch error:', error);
          this.toast.error(`取得エラー: ${error.message}. 開発者コンソールで詳細を確認してください。`, {
            title: 'エラー',
            duration: 8000
          });
        } finally {
          if (fetchBtn) {
            fetchBtn.classList.remove('loading');
            fetchBtn.disabled = false;
          }
        }
      }

      isValidAmazonUrl(url) {
        try {
          const urlObj = new URL(url);
          return urlObj.hostname.includes('amazon') && 
                 (url.includes('/dp/') || url.includes('/product/') || url.includes('/gp/product/'));
        } catch {
          return false;
        }
      }

      async scrapeAmazonData(url) {
        try {
          // Multiple CORS proxy attempts for reliability
          const proxies = [
            'https://api.allorigins.win/get?url=',
            'https://corsproxy.io/?',
            'https://cors-anywhere.herokuapp.com/'
          ];
          
          let response = null;
          let htmlContent = null;
          
          // Try each proxy until one works
          for (const proxy of proxies) {
            try {
              const proxyUrl = proxy + encodeURIComponent(url);
              console.log(`Trying proxy: ${proxy}`);
              
              const fetchResponse = await fetch(proxyUrl, {
                method: 'GET',
                headers: {
                  'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                  'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                  'Accept-Language': 'ja,en-US;q=0.7,en;q=0.3',
                  'Accept-Encoding': 'gzip, deflate, br'
                }
              });
              
              if (!fetchResponse.ok) {
                throw new Error(`HTTP error! status: ${fetchResponse.status}`);
              }
              
              const data = await fetchResponse.json();
              htmlContent = data.contents || data.response;
              
              if (htmlContent && htmlContent.length > 1000) {
                console.log('Successfully fetched data with proxy:', proxy);
                break;
              }
            } catch (error) {
              console.warn(`Proxy ${proxy} failed:`, error);
              continue;
            }
          }
          
          if (!htmlContent) {
            throw new Error('All proxies failed');
          }
          
          return this.parseAmazonHTML(htmlContent, url);
          
        } catch (error) {
          console.error('Real scraping failed, falling back to enhanced extraction:', error);
          
          // Enhanced fallback - try to extract ASIN and make educated guess
          return this.enhancedAmazonExtraction(url);
        }
      }

      parseAmazonHTML(html, url) {
        try {
          // Create a DOM parser to extract data
          const parser = new DOMParser();
          const doc = parser.parseFromString(html, 'text/html');
          
          // Extract title - multiple selectors for reliability
          const titleSelectors = [
            '#productTitle',
            '.product-title',
            '[data-automation-id="title"]',
            'h1.a-size-large',
            'h1 span'
          ];
          
          let title = null;
          for (const selector of titleSelectors) {
            const element = doc.querySelector(selector);
            if (element) {
              title = element.textContent.trim();
              if (title.length > 5) break;
            }
          }
          
          // Extract author - multiple approaches
          const authorSelectors = [
            '.author .contributorNameID',
            '.author a',
            '.by-author a',
            '[data-automation-id="byline"] a',
            '.a-size-base+ .a-size-base .a-link-normal'
          ];
          
          let author = null;
          for (const selector of authorSelectors) {
            const elements = doc.querySelectorAll(selector);
            if (elements.length > 0) {
              author = Array.from(elements)
                .map(el => el.textContent.trim())
                .filter(text => text.length > 2)
                .join(', ');
              if (author.length > 2) break;
            }
          }
          
          // Extract image URL
          const imageSelectors = [
            '#landingImage',
            '.frontImage img',
            '.itemImageBlock img',
            '#imgBlkFront',
            '#ebooksImgBlkFront'
          ];
          
          let imageUrl = null;
          for (const selector of imageSelectors) {
            const element = doc.querySelector(selector);
            if (element) {
              imageUrl = element.src || element.getAttribute('data-src');
              if (imageUrl && imageUrl.includes('amazon')) break;
            }
          }
          
          // Extract review count - multiple patterns
          const reviewSelectors = [
            '[data-hook="total-review-count"]',
            '.cr-widget-ACR .a-size-base',
            '.averageStarRating .a-size-base',
            '.a-link-normal .a-size-base'
          ];
          
          let reviewCount = 0;
          for (const selector of reviewSelectors) {
            const element = doc.querySelector(selector);
            if (element) {
              const text = element.textContent;
              const matches = text.match(/(\d{1,3}(?:,\d{3})*|\d+)/);
              if (matches) {
                reviewCount = parseInt(matches[1].replace(/,/g, ''));
                if (reviewCount > 0) break;
              }
            }
          }
          
          // Validate extracted data
          if (!title || title.length < 5) {
            throw new Error('Could not extract valid title');
          }
          
          return {
            title: title,
            author: author || '著者不明',
            imageUrl: imageUrl,
            currentReviews: reviewCount,
            extractedFrom: url,
            extractionTime: new Date().toISOString()
          };
          
        } catch (error) {
          console.error('HTML parsing failed:', error);
          throw error;
        }
      }

      async enhancedAmazonExtraction(url) {
        // Extract ASIN for potential API calls
        const asinMatch = url.match(/\/(?:dp|product)\/([A-Z0-9]{10})(?:\/|$|\?)/);
        const asin = asinMatch ? asinMatch[1] : null;
        
        if (!asin) {
          throw new Error('Could not extract ASIN from URL');
        }
        
        // Try alternative Amazon endpoints or APIs
        try {
          // Try Amazon's mobile API endpoint (sometimes less restricted)
          const mobileUrl = `https://www.amazon.co.jp/gp/aw/d/${asin}`;
          const response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(mobileUrl)}`);
          
          if (response.ok) {
            const data = await response.json();
            if (data.contents) {
              return this.parseAmazonHTML(data.contents, url);
            }
          }
        } catch (error) {
          console.warn('Enhanced extraction failed:', error);
        }
        
        // Final fallback - return structure for manual input
        throw new Error('Unable to extract book data automatically. Please enter manually.');
      }

      populateBookData(bookData) {
        const fields = [
          { id: 'title', value: bookData.title },
          { id: 'author', value: bookData.author },
          { id: 'imageUrl', value: bookData.imageUrl },
          { id: 'reviewCount', value: bookData.currentReviews || 0 }
        ];

        fields.forEach((field, index) => {
          setTimeout(() => {
            const element = document.getElementById(field.id);
            if (element) {
              element.style.background = 'linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(52, 211, 153, 0.05))';
              element.value = field.value;
              element.classList.add('animate-pulse');
              
              setTimeout(() => {
                element.style.background = '';
                element.classList.remove('animate-pulse');
              }, 500);
            }
          }, index * 200);
        });

        setTimeout(() => {
          this.animateSuccessFlash();
        }, fields.length * 200 + 300);
      }

      saveData() {
        const saveBtn = event?.target;
        if (saveBtn) {
          saveBtn.classList.add('animate-wiggle');
          setTimeout(() => saveBtn.classList.remove('animate-wiggle'), 800);
        }

        const data = {
          amazonUrl: document.getElementById('amazonUrl').value.trim(),
          title: document.getElementById('title').value.trim(),
          author: document.getElementById('author').value.trim(),
          imageUrl: document.getElementById('imageUrl').value.trim(),
          reviewCount: parseInt(document.getElementById('reviewCount').value) || 0,
          targetReviews: parseInt(document.getElementById('targetReviews').value) || 0,
          savedAt: new Date().toISOString()
        };

        if (!data.title) {
          this.animateInputError('title');
          this.toast.error('書籍タイトルを入力してください', {
            title: '入力エラー'
          });
          return;
        }

        // 目標レビュー数は任意。未入力や0以下は保存し、進捗表示では非表示にします。

        if (this.storage.save(data)) {
          this.animateSuccessFlash();
          this.toast.success(`「${data.title}」の設定を保存しました`, {
            title: '保存完了',
            duration: 4000
          });
        } else {
          this.toast.error('保存に失敗しました', {
            title: '保存エラー'
          });
        }
      }

      async clearData() {
        const confirmed = confirm('データを削除しますか？');

        if (confirmed) {
          if (this.storage.clear()) {
            document.getElementById('amazonUrl').value = '';
            document.getElementById('title').value = '';
            document.getElementById('author').value = '';
            document.getElementById('imageUrl').value = '';
            document.getElementById('reviewCount').value = '0';
            document.getElementById('targetReviews').value = '';
            
            this.toast.success('データを削除しました', {
              title: '削除完了'
            });
          } else {
            this.toast.error('削除に失敗しました', {
              title: '削除エラー'
            });
          }
        }
      }

      showProgress() {
        const data = this.storage.load();
        const content = document.getElementById('progress-content');
        
        if (!data) {
          content.innerHTML = '<p>設定タブでデータを入力してください。</p>';
          return;
        }

        const current = Number(data.reviewCount) || 0;
        const targetRaw = Number(data.targetReviews);
        const hasTarget = Number.isFinite(targetRaw) && targetRaw > 0;
        const target = hasTarget ? targetRaw : 0;
        const percentage = hasTarget ? Math.min(Math.round((current / target) * 100), 100) : 0;
        const remaining = hasTarget ? Math.max(target - current, 0) : 0;

        console.log('Progress data:', { current, target, percentage, remaining });

        const milestone = percentage >= 100 ? '🎉 目標達成！' : 
                         percentage >= 80 ? '🔥 もうすぐ達成！' :
                         percentage >= 50 ? '📈 順調です' : '💪 がんばりましょう';

        const statsHtml = hasTarget ? `
              <div class=\"progress-stats\">
                <span class=\"target-info\">目標: ${target} レビュー</span>
                <span class=\"remaining-info\">あと ${remaining} レビュー</span>
              </div>
            ` : '';

        const progressSectionHtml = hasTarget ? `
            <div class="progress-section">
              <div class="progress-bar">
                <div class="progress-fill" style="width: ${Math.max(percentage, 2)}%"></div>
                <div class="progress-text">${percentage}%</div>
              </div>
              ${statsHtml}
            </div>
          ` : '';

        content.innerHTML = `
          <div class="progress-display vertical">
            <div class="book-cover-section">
              <div class="book-cover" id="book-cover">
              </div>
            </div>
            
            <div class="book-meta">
              <h4 class="book-title">${data.title || 'タイトル未設定'}</h4>
              <p class="book-author">${data.author || '著者未設定'}</p>
            </div>
            
            <div class="current-reviews-highlight">
              <div class="current-number">${current}</div>
              <div class="current-label">現在のレビュー数</div>
            </div>
            
            ${progressSectionHtml}
            
            <div class="milestone">${milestone}</div>
          </div>
        `;

        const bookCoverContainer = content.querySelector('#book-cover');
        if (data.imageUrl && data.imageUrl.trim()) {
          const img = document.createElement('img');
          img.src = data.imageUrl.trim();
          img.alt = data.title || '書籍';
          
          img.onerror = () => {
            bookCoverContainer.innerHTML = `
              <div class="no-image">
                <div style="font-size: 28px; margin-bottom: 8px;">📚</div>
                <div>画像読み込みエラー</div>
              </div>
            `;
          };
          
          bookCoverContainer.appendChild(img);
        } else {
          bookCoverContainer.innerHTML = `
            <div class="no-image">
              <div style="font-size: 28px; margin-bottom: 8px;">📚</div>
              <div>画像なし</div>
            </div>
          `;
        }

        const actionsDiv = document.getElementById('progress-actions');
        if (actionsDiv) {
          actionsDiv.style.display = 'flex';
        }

        if (hasTarget && percentage > 0) {
          this.toast.info(`進捗: ${percentage}% (${current}/${target})`, {
            title: '進捗確認',
            duration: 3000
          });
        }
      }

      async updateReviewCount() {
        const data = this.storage.load();
        if (!data || !data.amazonUrl) {
          this.toast.warning('Amazon URLが設定されていません', {
            title: '更新失敗'
          });
          return;
        }

        const updateBtn = event?.target;
        if (updateBtn) {
          updateBtn.classList.add('loading');
          updateBtn.disabled = true;
        }

        try {
          this.toast.info('最新のレビュー数を確認中...', {
            title: 'データ更新中'
          });

          await new Promise(resolve => setTimeout(resolve, 2000));
          
          const currentCount = data.reviewCount || 0;
          const newCount = Math.max(currentCount, currentCount + Math.floor(Math.random() * 5));
          
          const updatedData = { ...data, reviewCount: newCount };
          this.storage.save(updatedData);
          
          document.getElementById('reviewCount').value = newCount;
          this.showProgress();
          
          this.toast.success(`レビュー数を更新しました: ${currentCount} → ${newCount}`, {
            title: '更新完了',
            duration: 4000
          });
          
        } catch (error) {
          this.toast.error('更新中にエラーが発生しました', {
            title: '更新エラー'
          });
        } finally {
          if (updateBtn) {
            updateBtn.classList.remove('loading');
            updateBtn.disabled = false;
          }
        }
      }



      loadData() {
        const data = this.storage.load();
        if (data) {
          document.getElementById('amazonUrl').value = data.amazonUrl || '';
          document.getElementById('title').value = data.title || '';
          document.getElementById('author').value = data.author || '';
          document.getElementById('imageUrl').value = data.imageUrl || '';
          document.getElementById('reviewCount').value = data.reviewCount || 0;
          document.getElementById('targetReviews').value = data.targetReviews || '';
        }
      }

      animateInputError(inputId) {
        const input = document.getElementById(inputId);
        if (input) {
          input.style.borderColor = 'var(--danger)';
          input.classList.add('animate-wiggle');
          setTimeout(() => {
            input.classList.remove('animate-wiggle');
            input.style.borderColor = '';
          }, 800);
        }
      }

      animateSuccessFlash() {
        const card = document.querySelector('.card');
        if (card) {
          const flash = document.createElement('div');
          flash.style.cssText = `
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(52, 211, 153, 0.1));
            border-radius: inherit;
            animation: fadeInUp 0.6s var(--transition-normal);
            pointer-events: none;
            z-index: 1;
          `;
          card.style.position = 'relative';
          card.appendChild(flash);
          
          setTimeout(() => {
            if (flash.parentNode) {
              flash.parentNode.removeChild(flash);
            }
          }, 600);
        }
      }

      async exportProgressImageNew() {
        const data = this.storage.load();
        if (!data) {
          this.toast.warning('エクスポートするデータがありません', {
            title: 'エクスポート失敗'
          });
          return;
        }

        const current = Number(data.reviewCount) || 0;
        const targetRaw = Number(data.targetReviews);
        const hasTarget = Number.isFinite(targetRaw) && targetRaw > 0;
        const target = hasTarget ? targetRaw : 0;
        const percentage = hasTarget ? Math.min(Math.round((current / target) * 100), 100) : 0;
        const remaining = hasTarget ? Math.max(target - current, 0) : 0;

        try {
          this.toast.info('X投稿用の画像を生成中...', {
            title: '画像生成中',
            duration: 3000
          });

          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          // 3:4 ratio (vertical) for X/Twitter - 420x560px
          canvas.width = 420;
          canvas.height = 560;

          // Beautiful 3-color radial gradient background
          // Create multiple radial gradients for organic, random-looking effect
          
          // Base gradient (diagonal) - softer color palette
          const baseGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
          baseGradient.addColorStop(0, '#67e8f9'); // 水色 (cyan-300)
          baseGradient.addColorStop(0.5, '#f9a8d4'); // ピンク (pink-300)
          baseGradient.addColorStop(1, '#a7f3d0'); // 薄い黄緑 (emerald-200)
          ctx.fillStyle = baseGradient;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Overlay radial gradients for depth and randomness
          ctx.globalCompositeOperation = 'overlay';
          
          // First radial overlay (top-left area) - 水色中心
          const radial1 = ctx.createRadialGradient(canvas.width * 0.3, canvas.height * 0.2, 0, canvas.width * 0.3, canvas.height * 0.2, canvas.width * 0.8);
          radial1.addColorStop(0, 'rgba(103, 232, 249, 0.4)'); // 水色
          radial1.addColorStop(0.6, 'rgba(167, 243, 208, 0.3)'); // 薄い黄緑
          radial1.addColorStop(1, 'transparent');
          ctx.fillStyle = radial1;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Second radial overlay (bottom-right area) - ピンク中心
          const radial2 = ctx.createRadialGradient(canvas.width * 0.7, canvas.height * 0.8, 0, canvas.width * 0.7, canvas.height * 0.8, canvas.width * 0.6);
          radial2.addColorStop(0, 'rgba(249, 168, 212, 0.5)'); // ピンク
          radial2.addColorStop(0.5, 'rgba(103, 232, 249, 0.2)'); // 水色
          radial2.addColorStop(1, 'transparent');
          ctx.fillStyle = radial2;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Third radial overlay (center area) - 薄い黄緑中心
          const radial3 = ctx.createRadialGradient(canvas.width * 0.5, canvas.height * 0.4, 0, canvas.width * 0.5, canvas.height * 0.4, canvas.width * 0.4);
          radial3.addColorStop(0, 'rgba(167, 243, 208, 0.4)'); // 薄い黄緑
          radial3.addColorStop(0.8, 'rgba(249, 168, 212, 0.2)'); // ピンク
          radial3.addColorStop(1, 'transparent');
          ctx.fillStyle = radial3;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Reset composite operation for normal drawing
          ctx.globalCompositeOperation = 'source-over';

          // Add subtle background pattern that complements the new softer gradient
          const patternGradient = ctx.createRadialGradient(canvas.width * 0.15, canvas.height * 0.15, 0, canvas.width * 0.15, canvas.height * 0.15, 120);
          patternGradient.addColorStop(0, 'rgba(103, 232, 249, 0.08)'); // 水色パターン
          patternGradient.addColorStop(1, 'transparent');
          ctx.fillStyle = patternGradient;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          const patternGradient2 = ctx.createRadialGradient(canvas.width * 0.85, canvas.height * 0.85, 0, canvas.width * 0.85, canvas.height * 0.85, 100);
          patternGradient2.addColorStop(0, 'rgba(167, 243, 208, 0.06)'); // 薄い黄緑パターン
          patternGradient2.addColorStop(1, 'transparent');
          ctx.fillStyle = patternGradient2;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Main container (same as progress display)
          const cardX = 15;
          const cardY = 15;
          const cardWidth = canvas.width - 30;
          const cardHeight = canvas.height - 30;
          
          // Main card background (white, rounded, subtle shadow)
          ctx.save();
          ctx.shadowColor = 'rgba(0, 0, 0, 0.12)';
          ctx.shadowBlur = 20;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 8;
          ctx.fillStyle = 'rgba(255, 255, 255, 0.96)';
          this.roundRect(ctx, cardX, cardY, cardWidth, cardHeight, 24);
          ctx.fill();
          ctx.restore();
          // Border similar to UI (--border)
          ctx.strokeStyle = 'rgba(226, 232, 240, 0.8)';
          ctx.lineWidth = 1;
          ctx.stroke();

          // Add small decorative dot (same as web app)
          ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
          ctx.beginPath();
          ctx.arc(cardX + cardWidth - 20, cardY + 20, 6, 0, 2 * Math.PI);
          ctx.fill();

          // Content positioning
          const contentStartY = cardY + 40;

          // Book cover (top center) - slightly smaller to give more space to text
          const coverX = (canvas.width - 130) / 2; // Center horizontally
          const coverY = contentStartY;
          const coverWidth = 130;
          const coverHeight = 195;

          // Try to load and draw book cover image
          if (data.imageUrl && data.imageUrl.trim()) {
            try {
              await this.drawBookCoverOnCanvas(ctx, data.imageUrl.trim(), coverX, coverY, coverWidth, coverHeight);
            } catch (error) {
              console.log('Failed to load book image, using placeholder');
              this.drawBookPlaceholder(ctx, coverX, coverY, coverWidth, coverHeight);
            }
          } else {
            this.drawBookPlaceholder(ctx, coverX, coverY, coverWidth, coverHeight);
          }

          // Book meta (below cover)
          const metaY = coverY + coverHeight + 20;
          const safePad = 40; // increased inner padding for better text space
          const leftBound = cardX + safePad;
          const rightBound = cardX + cardWidth - safePad;
          ctx.textAlign = 'center';

          // Clip text and UI content to an inner safe area of the white card
          ctx.save();
          this.roundRect(ctx, leftBound, cardY + safePad, cardWidth - safePad * 2, cardHeight - safePad * 2, 16);
          ctx.clip();
          
          // Small title with centered wrapping within [leftBound, rightBound]
          ctx.fillStyle = '#1a202c';
          const title = data.title || 'タイトル未設定';
          // Dynamic font size based on title length - slightly larger
          const fontSize = title.length > 25 ? 12 : title.length > 20 ? 13 : 15;
          ctx.font = `bold ${fontSize}px -apple-system, BlinkMacSystemFont, sans-serif`;
          const centerX = (leftBound + rightBound) / 2;
          const availableWidth = rightBound - leftBound;
          console.log('Drawing title:', title, 'Available width:', availableWidth, 'Font size:', fontSize);
          const titleLastY = this.wrapTextBoundedCenterImproved(ctx, title, centerX, metaY, leftBound, rightBound, 17);
          
          // Small author (centered, bounded)
          ctx.font = '11px -apple-system, BlinkMacSystemFont, sans-serif';
          ctx.fillStyle = '#4a5568';
          const author = data.author || '著者未設定';
          const authorY = titleLastY + 21; // タイトル行数に連動
          console.log('Drawing author centered bounded:', author, 'bounds:', leftBound, rightBound, 'at y:', authorY);
          const authorLastY = this.wrapTextBoundedCenterImproved(ctx, author, centerX, authorY, leftBound, rightBound, 14);

          // Current review count (prominent) - with subtle glow
          const currentY = authorLastY + 36; // タイトル・著者の高さに応じて配置
          
          ctx.font = 'bold 56px -apple-system, BlinkMacSystemFont, sans-serif';
          const currentGradient = ctx.createLinearGradient(0, currentY, 0, currentY + 56);
          ctx.textAlign = 'center';
          currentGradient.addColorStop(0, '#3b82f6');
          currentGradient.addColorStop(1, '#06b6d4');
          ctx.fillStyle = currentGradient;
          console.log('Drawing current reviews:', current.toString(), 'at position:', canvas.width / 2, currentY);
          // Glow
          ctx.save();
          ctx.textBaseline = 'top';
          ctx.shadowColor = 'rgba(139, 92, 246, 0.45)';
          ctx.shadowBlur = 18;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 0;
          ctx.fillText(current.toString(), canvas.width / 2, currentY);
          ctx.restore();
          // Main text on top for crisp edges
          ctx.save();
          ctx.textBaseline = 'top';
          ctx.fillText(current.toString(), canvas.width / 2, currentY);
          ctx.restore();

          // "現在のレビュー数" label
          ctx.font = 'bold 14px -apple-system, BlinkMacSystemFont, sans-serif';
          ctx.fillStyle = '#4a5568';
          console.log('Drawing current label at position:', canvas.width / 2, currentY + 56 + 8);
          ctx.fillText('現在のレビュー数', canvas.width / 2, currentY + 56 + 8);

          // Progress bar and stats only when target is set
          if (hasTarget) {
            // Progress bar (prominent)
            const progressBarY = currentY + 56 + 28;
            const progressBarWidth = cardWidth - 60;
            const progressBarHeight = 24;
            const progressBarX = (canvas.width - progressBarWidth) / 2;

            // Progress bar background with rounded ends
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            const borderRadius = progressBarHeight / 2; // Full rounded ends
            this.roundRect(ctx, progressBarX, progressBarY, progressBarWidth, progressBarHeight, borderRadius);
            ctx.fill();
            ctx.stroke();

            // Progress bar fill (match UI gradient) with properly rounded ends
            if (percentage > 0) {
              const fillWidth = Math.max((progressBarWidth * percentage) / 100, borderRadius * 2);
              const progressGradient = ctx.createLinearGradient(progressBarX, progressBarY, progressBarX + progressBarWidth, progressBarY + progressBarHeight);
              progressGradient.addColorStop(0.0, '#3b82f6');
              progressGradient.addColorStop(0.6, '#06b6d4');
              progressGradient.addColorStop(1.0, '#10b981');
              ctx.fillStyle = progressGradient;
              
              // Draw progress fill with rounded ends
              // For 100%, use full width. For others, ensure minimum width for proper rounding
              if (percentage >= 100) {
                // Full width with both ends rounded
                this.roundRect(ctx, progressBarX, progressBarY, progressBarWidth, progressBarHeight, borderRadius);
              } else {
                // Partial width but with both ends rounded for visual consistency
                this.roundRect(ctx, progressBarX, progressBarY, fillWidth, progressBarHeight, borderRadius);
              }
              ctx.fill();
            }

            // Progress percentage (improved visibility)
            ctx.font = 'bold 14px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = '#1a202c';
            ctx.textAlign = 'center';
            console.log('Drawing progress percentage:', `${percentage}%`, 'at position:', canvas.width / 2, progressBarY + 17);
            ctx.fillText(`${percentage}%`, canvas.width / 2, progressBarY + 17);

            // Stats section - only if target specified (add more spacing)
            const statsY = progressBarY + 40;
            const cardWidth1 = (cardWidth - 80) / 2;
            const cardHeight1 = 28;
            const gap = 10;

            // Target card (emphasized border and fill)
            const targetCardX = cardX + 30;
            ctx.save();
            ctx.shadowColor = 'rgba(0, 0, 0, 0.08)';
            ctx.shadowBlur = 12;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 4;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            this.roundRect(ctx, targetCardX, statsY, cardWidth1, cardHeight1, 8);
            ctx.fill();
            ctx.restore();
            ctx.strokeStyle = 'rgba(226, 232, 240, 1)';
            ctx.lineWidth = 1;
            this.roundRect(ctx, targetCardX, statsY, cardWidth1, cardHeight1, 8);
            ctx.stroke();
            ctx.font = '10px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = '#1f2937';
            ctx.textAlign = 'center';
            ctx.fillText(`目標: ${target} レビュー`, targetCardX + cardWidth1/2, statsY + cardHeight1/2 + 3);

            // Remaining card (emphasized)
            const remainingCardX = targetCardX + cardWidth1 + gap;
            ctx.save();
            ctx.shadowColor = 'rgba(0, 0, 0, 0.08)';
            ctx.shadowBlur = 12;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 4;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            this.roundRect(ctx, remainingCardX, statsY, cardWidth1, cardHeight1, 8);
            ctx.fill();
            ctx.restore();
            ctx.strokeStyle = 'rgba(226, 232, 240, 1)';
            ctx.lineWidth = 1;
            this.roundRect(ctx, remainingCardX, statsY, cardWidth1, cardHeight1, 8);
            ctx.stroke();
            ctx.fillStyle = '#1f2937';
            ctx.fillText(`あと ${remaining} レビュー`, remainingCardX + cardWidth1/2, statsY + cardHeight1/2 + 3);
          }

          // (Removed) milestone and branding to maximize content space

          // Restore to remove clip (if any content later needs to overflow)
          ctx.restore();

          // Convert to blob and download
          canvas.toBlob((blob) => {
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `kindle-review-progress-${current}-${target}-${Date.now()}.png`;
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            URL.revokeObjectURL(url);
            
            this.toast.success('X投稿用画像をダウンロードしました！', {
              title: '画像エクスポート完了',
              duration: 5000
            });
          }, 'image/png');

        } catch (error) {
          console.error('Image export failed:', error);
          this.toast.error('画像エクスポートに失敗しました', {
            title: 'エクスポートエラー'
          });
        }
      }

      // 古い関数を完全に削除して新しい関数を追加
      async exportProgressImage() {
        console.log('NEW EXPORT FUNCTION CALLED!');
        return this.exportProgressImageNew();
      }

      async drawBookCoverOnCanvas(ctx, imageUrl, x, y, width, height) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => {
            // Save state before clipping/shadow
            ctx.save();

            // Draw shadow + clipped image
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 8;

            this.roundRect(ctx, x, y, width, height, 16);
            ctx.clip();
            ctx.drawImage(img, x, y, width, height);

            // Restore to clear clip/shadow
            ctx.restore();

            // Draw border on a clean state
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 3;
            this.roundRect(ctx, x, y, width, height, 16);
            ctx.stroke();
            ctx.restore();

            resolve();
          };
          img.onerror = reject;
          img.src = imageUrl;
        });
      }

      drawBookPlaceholder(ctx, x, y, width, height) {
        // Shadow
        ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
        ctx.shadowBlur = 15;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 8;

        // Background
        const gradient = ctx.createLinearGradient(x, y, x, y + height);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0.05)');
        ctx.fillStyle = gradient;
        this.roundRect(ctx, x, y, width, height, 16);
        ctx.fill();

        // Reset shadow
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;

        // Border
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 2;
        this.roundRect(ctx, x, y, width, height, 16);
        ctx.stroke();

        // Book icon
        ctx.font = '48px Inter, system-ui';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.textAlign = 'center';
        ctx.fillText('📚', x + width / 2, y + height / 2 + 10);

        // "画像なし" text
        ctx.font = '12px Inter, system-ui';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.fillText('画像なし', x + width / 2, y + height / 2 + 35);
      }


      wrapText(ctx, text, x, y, maxWidth, lineHeight) {
        // Support languages without spaces (e.g., Japanese)
        const hasSpace = text.includes(' ');
        const tokens = hasSpace ? text.split(' ') : Array.from(text);
        let line = '';
        for (let i = 0; i < tokens.length; i++) {
          const sep = hasSpace ? ' ' : '';
          const testLine = line + tokens[i] + sep;
          const testWidth = ctx.measureText(testLine).width;
          if (testWidth > maxWidth && line) {
            ctx.fillText(line, x, y);
            line = tokens[i] + sep;
            y += lineHeight;
          } else {
            line = testLine;
          }
        }
        if (line) ctx.fillText(line, x, y);
        return y; // return baseline of last drawn line
      }

      // New: left-aligned bounded wrapping between [left, right]
      wrapTextBounded(ctx, text, left, top, right, lineHeight) {
        const maxWidth = Math.max(0, right - left);
        const originalAlign = ctx.textAlign;
        ctx.textAlign = 'left';
        const hasSpace = text.includes(' ');
        const tokens = hasSpace ? text.split(' ') : Array.from(text);
        let line = '';
        let y = top;
        for (let i = 0; i < tokens.length; i++) {
          const sep = hasSpace ? ' ' : '';
          const test = line + tokens[i] + sep;
          const w = ctx.measureText(test).width;
          if (w > maxWidth && line) {
            ctx.fillText(line, left, y);
            line = tokens[i] + sep;
            y += lineHeight;
          } else {
            line = test;
          }
        }
        if (line) ctx.fillText(line, left, y);
        ctx.textAlign = originalAlign;
        return y;
      }

      // New: centered text wrapping within [left, right]
      wrapTextBoundedCenter(ctx, text, centerX, top, left, right, lineHeight) {
        const maxWidth = Math.max(0, right - left);
        const originalAlign = ctx.textAlign;
        ctx.textAlign = 'center';
        const hasSpace = text.includes(' ');
        const tokens = hasSpace ? text.split(' ') : Array.from(text);
        const lines = [];
        let line = '';
        for (let i = 0; i < tokens.length; i++) {
          const sep = hasSpace ? ' ' : '';
          const test = line + tokens[i] + sep;
          const w = ctx.measureText(test).width;
          if (w > maxWidth && line) {
            lines.push(line.trimEnd());
            line = tokens[i] + sep;
          } else {
            line = test;
          }
        }
        if (line) lines.push(line.trimEnd());
        let y = top;
        for (const l of lines) {
          ctx.fillText(l, centerX, y);
          y += lineHeight;
        }
        ctx.textAlign = originalAlign;
        return y - lineHeight; // return last line baseline
      }

      // Improved: better Japanese text wrapping with character-level breaking
      wrapTextBoundedCenterImproved(ctx, text, centerX, top, left, right, lineHeight) {
        const maxWidth = Math.max(0, right - left) * 0.75; // Use 75% to force more line breaks
        const originalAlign = ctx.textAlign;
        ctx.textAlign = 'center';
        
        console.log('wrapTextBoundedCenterImproved:', text, 'Available space:', (right - left), 'maxWidth:', maxWidth);
        
        const lines = [];
        let line = '';
        
        // Character-level breaking with smart break points
        for (let i = 0; i < text.length; i++) {
          const char = text[i];
          const testLine = line + char;
          const testWidth = ctx.measureText(testLine).width;
          
          console.log(`Testing char "${char}": line="${line}" -> testLine="${testLine}", width=${testWidth}, max=${maxWidth}`);
          
          // Check if we need to break
          if (testWidth > maxWidth && line.length > 0) {
            // Try to find a better break point in the current line
            const breakChars = ['」', '）', '、', '。', ' ', '/', '(', '（'];
            let bestBreakPos = -1;
            
            // Look for good break points from the end of the line
            for (let j = line.length - 1; j >= Math.max(0, line.length - 5); j--) {
              if (breakChars.includes(line[j])) {
                bestBreakPos = j + 1;
                break;
              }
            }
            
            if (bestBreakPos > 0 && bestBreakPos < line.length) {
              // Break at the good position
              const beforeBreak = line.substring(0, bestBreakPos);
              const afterBreak = line.substring(bestBreakPos);
              console.log(`Smart breaking: "${beforeBreak}" | "${afterBreak}"`);
              lines.push(beforeBreak);
              line = afterBreak + char;
            } else {
              // No good break point, just break here
              console.log(`Breaking line: "${line}" (width: ${ctx.measureText(line).width})`);
              lines.push(line);
              line = char;
            }
          } else {
            line = testLine;
          }
        }
        
        // Add the last line if it exists
        if (line) {
          console.log(`Final line: "${line}" (width: ${ctx.measureText(line).width})`);
          lines.push(line);
        }
        
        console.log('Generated lines:', lines);
        
        let y = top;
        for (const l of lines) {
          console.log('Drawing line:', l, 'at:', centerX, y);
          ctx.fillText(l, centerX, y);
          y += lineHeight;
        }
        
        ctx.textAlign = originalAlign;
        return y - lineHeight; // return last line baseline
      }

      // Helper function to draw rounded rectangles
      roundRect(ctx, x, y, width, height, radius) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
      }
    }

    // Create global app instance
    window.app = new App();
  </script>
</body>
</html>
