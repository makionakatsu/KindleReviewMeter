<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kindle Review Meter (Complete Edition)</title>
  <!-- Cache buster: 2025-08-08-17:48 - Force reload -->
  <style>
    /* Modern CSS Variables */
    :root {
      /* Modern Color Palette */
      --bg-primary: linear-gradient(135deg, #0ea5e9 0%, #22d3ee 100%);
      --bg-secondary: #fafbfc;
      --fg-primary: #1a202c;
      --fg-secondary: #4a5568;
      --fg-muted: #718096;
      
      /* Brand Colors */
      --primary: linear-gradient(135deg, #3b82f6, #06b6d4);
      --primary-solid: #3b82f6;
      --accent: linear-gradient(135deg, #f43f5e, #fb7185);
      --accent-solid: #f43f5e;
      --warning: #fbbf24;
      --danger: #ef4444;
      --success: #10b981;
      --info: #3b82f6;
      
      /* Surface Colors */
      --surface: rgba(255, 255, 255, 0.95);
      --surface-elevated: rgba(255, 255, 255, 0.98);
      --glass: rgba(255, 255, 255, 0.25);
      --glass-border: rgba(255, 255, 255, 0.2);
      
      /* Borders & Effects */
      --border: rgba(226, 232, 240, 0.8);
      --border-light: #f1f5f9;
      --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.08);
      --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.1);
      --shadow-lg: 0 8px 25px rgba(0, 0, 0, 0.12);
      --shadow-xl: 0 20px 40px rgba(0, 0, 0, 0.15);
      --shadow-glass: 0 8px 32px rgba(31, 38, 135, 0.37);
      
      /* Spacing System */
      --space-xs: 0.25rem;
      --space-sm: 0.5rem;
      --space-md: 1rem;
      --space-lg: 1.5rem;
      --space-xl: 2rem;
      --space-2xl: 3rem;
      
      /* Border Radius */
      --radius-sm: 0.5rem;
      --radius-md: 0.75rem;
      --radius-lg: 1rem;
      --radius-xl: 1.5rem;
      --radius-2xl: 2rem;
      
      /* Transitions & Animation */
      --transition-fast: 0.15s cubic-bezier(0.4, 0, 0.2, 1);
      --transition-normal: 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      --transition-slow: 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      --transition-spring: 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      --transition-bounce: 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      --animation-duration: 0.6s;
    }

    /* Global Styles */
    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      color: var(--fg-primary);
      line-height: 1.6;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    body {
      min-height: 100vh;
      background: var(--bg-primary);
      position: relative;
    }

    /* Background Pattern */
    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background-image: 
        radial-gradient(circle at 25% 25%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 75% 75%, rgba(255, 255, 255, 0.05) 0%, transparent 50%);
      pointer-events: none;
      z-index: 1;
    }

    /* Header with Glassmorphism */
    .header {
      position: sticky;
      top: 0;
      z-index: 100;
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      background: var(--glass);
      border-bottom: 1px solid var(--glass-border);
      padding: var(--space-lg) 0;
      margin-bottom: var(--space-xl);
    }
    
    .header-content {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 var(--space-xl);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .header h1 {
      margin: 0;
      font-size: 1.75rem;
      font-weight: 800;
      background: linear-gradient(135deg, #ffffff, #f1f5f9);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .tabs {
      display: flex;
      gap: var(--space-sm);
      background: rgba(255, 255, 255, 0.1);
      padding: var(--space-xs);
      border-radius: var(--radius-2xl);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid var(--glass-border);
    }
    
    .tab {
      padding: var(--space-md) var(--space-lg);
      background: transparent;
      border: none;
      border-radius: var(--radius-xl);
      color: rgba(255, 255, 255, 0.8);
      cursor: pointer;
      font-weight: 600;
      font-size: 0.9rem;
      transition: all var(--transition-normal);
      position: relative;
      overflow: hidden;
    }
    
    .tab::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
      opacity: 0;
      transition: opacity var(--transition-normal);
    }
    
    .tab:hover::before {
      opacity: 1;
    }
    
    .tab.active {
      color: white;
      background: rgba(255, 255, 255, 0.2);
      box-shadow: var(--shadow-md);
      transform: translateY(-1px);
    }

    /* Main Container */
    .main-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 var(--space-xl);
      position: relative;
      z-index: 2;
    }
    
    .view {
      display: none;
      opacity: 0;
      transform: translateY(30px);
      transition: all var(--transition-slow);
    }
    
    .view.active {
      display: block;
      opacity: 1;
      transform: translateY(0);
    }
    
    /* Glassmorphism Cards */
    .card {
      background: var(--surface);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--border);
      border-radius: var(--radius-2xl);
      padding: var(--space-2xl);
      margin-bottom: var(--space-xl);
      box-shadow: var(--shadow-glass);
      transition: all var(--transition-normal);
      position: relative;
      overflow: hidden;
    }
    
    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: var(--primary);
      opacity: 0;
      transition: opacity var(--transition-normal);
    }
    
    .card:hover {
      transform: translateY(-8px);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
    }
    
    .card:hover::before {
      opacity: 1;
    }
    
    .card h2 {
      margin: 0 0 var(--space-xl) 0;
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--fg-primary);
      display: flex;
      align-items: center;
      gap: var(--space-md);
    }
    
    /* Form Styles */
    .form-grid {
      display: grid;
      gap: var(--space-lg);
    }
    
    .form-group {
      position: relative;
    }
    
    .form-group label {
      display: block;
      margin-bottom: var(--space-sm);
      font-weight: 600;
      color: var(--fg-primary);
      font-size: 0.9rem;
      letter-spacing: 0.01em;
    }
    
    .form-group input {
      width: 100%;
      padding: var(--space-lg);
      border: 2px solid var(--border);
      border-radius: var(--radius-lg);
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(10px);
      font-size: 1rem;
      transition: all var(--transition-normal);
      font-family: inherit;
    }
    
    .form-group input:focus {
      outline: none;
      border-color: var(--primary-solid);
      background: rgba(255, 255, 255, 0.95);
      box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.1);
      transform: translateY(-2px);
    }
    
    .form-group input::placeholder {
      color: var(--fg-muted);
      opacity: 0.7;
    }

    /* Flex input group for URL + button */
    .input-group {
      display: flex;
      gap: var(--space-md);
    }

    .input-group input {
      flex: 1;
    }

    .input-group .btn {
      flex-shrink: 0;
      margin: 0;
    }
    
    /* Button System */
    .btn-group {
      display: flex;
      gap: var(--space-md);
      flex-wrap: wrap;
      margin-top: var(--space-xl);
    }
    
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-sm);
      padding: var(--space-lg) var(--space-xl);
      border: 2px solid transparent;
      border-radius: var(--radius-lg);
      font-size: 0.9rem;
      font-weight: 600;
      text-decoration: none;
      cursor: pointer;
      transition: all var(--transition-normal);
      position: relative;
      overflow: hidden;
      min-height: 48px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    
    .btn::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, transparent, rgba(255, 255, 255, 0.1));
      opacity: 0;
      transition: opacity var(--transition-fast);
    }
    
    .btn:hover::before {
      opacity: 1;
    }
    
    .btn:hover {
      transform: translateY(-3px) scale(1.02);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
      animation: none;
    }
    
    .btn:active {
      transform: translateY(-1px) scale(0.98);
      transition: all var(--transition-fast);
    }
    
    .btn.primary {
      background: var(--primary);
      color: white;
      box-shadow: var(--shadow-md);
    }
    
    .btn.secondary {
      background: rgba(255, 255, 255, 0.9);
      color: var(--fg-primary);
      border-color: var(--border);
    }
    
    .btn.secondary:hover {
      background: rgba(255, 255, 255, 1);
      border-color: var(--primary-solid);
    }
    
    .btn.danger {
      background: linear-gradient(135deg, var(--danger), #dc2626);
      color: white;
    }

    /* Loading States */
    .btn.loading {
      pointer-events: none;
      position: relative;
      color: transparent;
    }

    .btn.loading::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: translate(-50%, -50%) rotate(360deg);
      }
    }
    
    /* Progress Display - 3:4 Vertical Layout */
    .progress-display.vertical {
      display: flex;
      flex-direction: column;
      width: 420px; /* 3:4 ratio base - 420px width */
      height: 560px; /* 3:4 ratio base - 560px height (420*4/3) */
      margin: 0 auto;
      padding: var(--space-lg);
      background: 
        rgba(255, 255, 255, 0.05),
        radial-gradient(circle at 20% 20%, rgba(14, 165, 233, 0.05) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(34, 211, 238, 0.05) 0%, transparent 50%);
      border-radius: var(--radius-xl);
      backdrop-filter: blur(10px);
      gap: var(--space-sm);
      position: relative;
      overflow: visible;
    }

    .progress-display.vertical::before {
      content: '';
      position: absolute;
      top: 15px;
      right: 15px;
      width: 12px;
      height: 12px;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.2), transparent);
      border-radius: 50%;
    }
    
    /* Book Cover Section - Top Center */
    .book-cover-section {
      display: flex;
      justify-content: center;
      margin-bottom: var(--space-md);
    }
    
    .book-cover {
      flex-shrink: 0;
    }
    
    .book-cover img {
      width: 120px;
      height: 180px;
      object-fit: cover;
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-xl), 0 0 20px rgba(139, 92, 246, 0.1);
      transition: all var(--transition-normal);
      border: 3px solid rgba(255, 255, 255, 0.2);
      position: relative;
    }
    
    .book-cover img:hover {
      transform: scale(1.02) rotateY(2deg);
      box-shadow: 0 25px 50px rgba(0, 0, 0, 0.25), 0 0 30px rgba(139, 92, 246, 0.2);
    }
    
    .book-cover .no-image {
      width: 120px;
      height: 180px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
      border: 2px dashed rgba(255, 255, 255, 0.3);
      border-radius: var(--radius-lg);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      color: rgba(255, 255, 255, 0.7);
      font-size: 12px;
      text-align: center;
      backdrop-filter: blur(10px);
    }

    /* Book Meta - Small Title and Author */
    .book-meta {
      text-align: center;
      margin-bottom: var(--space-xs);
      width: 100%;
      max-width: 380px;
      margin-left: auto;
      margin-right: auto;
    }

    .book-title {
      font-size: 0.95rem;
      font-weight: 600;
      color: #1a202c;
      margin: 0 0 var(--space-xs) 0;
      line-height: 1.3;
      max-width: 220px; /* tighten to avoid rim */
      word-wrap: break-word;
      overflow-wrap: anywhere; /* allow earlier wrapping for long CJK */
      hyphens: auto;
      white-space: normal;
      text-align: center;
      padding: 0 32px; /* doubled inner padding */
      margin-left: auto;
      margin-right: auto;
    }

    .book-author {
      font-size: 0.8rem;
      color: #4a5568;
      margin: 0;
      font-weight: 400;
      max-width: 220px; /* sync with title width */
      word-wrap: break-word;
      overflow-wrap: anywhere;
      text-align: center;
      padding: 0 32px; /* doubled inner padding */
      margin-left: auto;
      margin-right: auto;
    }

    /* Current Reviews Highlight - Main Focus */
    .current-reviews-highlight {
      text-align: center;
      margin: var(--space-md) 0 0 0;
      padding: var(--space-md) 0;
      position: relative;
    }


    .current-number {
      font-size: 3.5rem; /* å°‘ã—å¤§ãã */
      font-weight: 800;
      background: linear-gradient(135deg, #3b82f6, #06b6d4, #10b981);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow:
        0 2px 8px rgba(14, 165, 233, 0.28),
        0 0 18px rgba(14, 165, 233, 0.22); /* å¾Œå…‰æ„Ÿã‚’å¼·åŒ– */
      line-height: 1;
      margin-bottom: var(--space-sm);
      position: relative;
      z-index: 1;
      filter: drop-shadow(0 0 18px rgba(14, 165, 233, 0.25));
    }

    .current-label {
      font-size: 0.85rem;
      color: #4a5568;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* Progress Section */
    .progress-section {
      margin-top: 0;
    }

    .progress-stats {
      display: flex;
      justify-content: space-between;
      gap: var(--space-md);
      margin-top: var(--space-md);
    }

    .target-info, .remaining-info {
      flex: 1;
      text-align: center;
      padding: var(--space-sm) var(--space-md);
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.08));
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: var(--radius-lg);
      backdrop-filter: blur(10px);
      font-size: 0.8rem;
      color: #374151;
      font-weight: 500;
      transition: all var(--transition-fast);
      position: relative;
      overflow: hidden;
      box-shadow: var(--shadow-md), 0 0 12px rgba(139, 92, 246, 0.15);
    }

    .target-info::before, .remaining-info::before {
      content: '';
      position: absolute;
      top: 6px;
      right: 8px;
      width: 4px;
      height: 4px;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 50%;
    }

    .target-info:hover, .remaining-info:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg), 0 0 16px rgba(139, 92, 246, 0.2);
    }
    
    .book-info {
      flex: 1;
    }
    
    .book-info h3 {
      margin: 0 0 var(--space-md) 0;
      font-size: 1.75rem;
      font-weight: 800;
      color: var(--fg-primary);
      line-height: 1.2;
    }
    
    .book-info .author,
    .book-info .target {
      margin: var(--space-sm) 0;
      color: var(--fg-secondary);
      font-size: 1rem;
    }
    
    /* Modern Progress Bar */
    .progress-bar {
      background: rgba(255, 255, 255, 0.2);
      height: 32px;
      border-radius: var(--radius-2xl);
      overflow: hidden;
      margin: var(--space-xl) 0;
      position: relative;
      backdrop-filter: blur(10px);
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.3);
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(135deg, #3b82f6, #06b6d4, #10b981) !important;
      border-radius: var(--radius-2xl);
      transition: width var(--transition-slow) ease-out;
      position: relative;
      min-width: 2px;
      box-shadow: 0 2px 8px rgba(14, 165, 233, 0.35), 0 0 16px rgba(14, 165, 233, 0.2);
      overflow: hidden;
    }

    .progress-fill::after {
      content: '';
      position: absolute;
      top: 2px;
      right: 8px;
      width: 20px;
      height: 20px;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.8), transparent);
      border-radius: 50%;
      opacity: 0.7;
    }

    /* stripes removed for simpler, clean look */
    
    .progress-text {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      color: #1a202c; /* è¦–èªæ€§å‘ä¸Šã®ãŸã‚æ¿ƒè‰² */
      font-weight: 800;
      font-size: 1rem;
      text-shadow: 0 1px 0 rgba(255, 255, 255, 0.6);
      z-index: 2;
    }
    
    /* Statistics Grid */
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: var(--space-lg);
      margin: var(--space-2xl) 0;
    }
    
    .stat {
      background: var(--surface-elevated);
      backdrop-filter: blur(20px);
      padding: var(--space-xl);
      border-radius: var(--radius-xl);
      text-align: center;
      border: 1px solid var(--border);
      transition: all var(--transition-normal);
      position: relative;
      overflow: hidden;
    }
    
    .stat::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: var(--accent);
    }
    
    .stat:hover {
      transform: translateY(-4px);
      box-shadow: var(--shadow-lg);
    }
    
    .stat-value {
      font-size: 2.5rem;
      font-weight: 900;
      background: var(--primary);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: var(--space-sm);
      display: block;
    }
    
    .stat-label {
      color: var(--fg-muted);
      font-size: 0.875rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .milestone {
      text-align: center;
      font-size: 1.25rem;
      font-weight: 700;
      margin-top: var(--space-xl);
      padding: var(--space-lg);
      background: rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-lg);
      backdrop-filter: blur(10px);
    }

    /* Animations */
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes pulse {
      0% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.05);
      }
      100% {
        transform: scale(1);
      }
    }

    @keyframes wiggle {
      0%, 7% {
        transform: rotateZ(0);
      }
      15% {
        transform: rotateZ(-15deg);
      }
      20% {
        transform: rotateZ(10deg);
      }
      25% {
        transform: rotateZ(-10deg);
      }
      30% {
        transform: rotateZ(6deg);
      }
      35% {
        transform: rotateZ(-4deg);
      }
      40%, 100% {
        transform: rotateZ(0);
      }
    }

    .animate-wiggle {
      animation: wiggle 0.8s var(--transition-normal);
    }

    .animate-pulse {
      animation: pulse 0.5s var(--transition-normal);
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .header-content {
        flex-direction: column;
        gap: var(--space-lg);
      }
      
      .main-container {
        padding: 0 var(--space-lg);
      }
      
      .card {
        padding: var(--space-xl);
      }
      
      .progress-display.vertical {
        width: 350px;
        height: 467px; /* 350*4/3 */
        padding: var(--space-lg); /* add inner safe space on mobile */
      }

      .book-title {
        font-size: 0.9rem;
        max-width: 200px;
        margin-left: auto;
        margin-right: auto;
        overflow-wrap: anywhere;
        padding: 0 32px; /* doubled on mobile too */
      }

      .book-author {
        font-size: 0.75rem;
        max-width: 200px;
        margin-left: auto;
        margin-right: auto;
        overflow-wrap: anywhere;
        padding: 0 32px; /* doubled on mobile too */
      }
      
      .book-cover img,
      .book-cover .no-image {
        width: 100px;
        height: 150px;
      }
      
      .current-number {
        font-size: 2.5rem;
      }
      
      .book-cover img,
      .book-cover .no-image {
        width: 120px;
        height: 180px;
      }
      
      .btn-group {
        flex-direction: column;
      }
      
      .stats {
        grid-template-columns: 1fr;
        gap: var(--space-md);
      }

      .input-group {
        flex-direction: column;
      }

      .input-group .btn {
        flex: none;
      }
    }

    /* Toast System */
    .toast-container {
      position: fixed;
      top: 120px; /* Below header and tabs */
      right: var(--space-xl);
      display: flex;
      flex-direction: column;
      gap: var(--space-md);
      z-index: 1000;
      pointer-events: none;
    }

    @media (max-width: 640px) {
      .toast-container {
        top: 140px; /* Extra space for mobile stacked header */
        right: var(--space-lg);
        left: var(--space-lg);
      }
    }

    .toast {
      min-width: 280px;
      max-width: 320px;
      background: var(--surface);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-md);
      opacity: 0;
      transform: translateX(400px);
      transition: all var(--transition-normal) cubic-bezier(0.4, 0, 0.2, 1);
      pointer-events: auto;
      position: relative;
    }

    .toast.show {
      opacity: 1;
      transform: translateX(0);
    }

    .toast.removing {
      opacity: 0;
      transform: translateX(400px);
      max-height: 0;
      margin-bottom: 0;
    }

    .toast-content {
      display: flex;
      align-items: flex-start;
      padding: var(--space-md) var(--space-lg);
      gap: var(--space-sm);
    }

    .toast-icon {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
      flex-shrink: 0;
    }

    .toast-success .toast-icon {
      background: rgba(16, 185, 129, 0.1);
      color: var(--success);
    }

    .toast-warning .toast-icon {
      background: rgba(251, 191, 36, 0.1);
      color: var(--warning);
    }

    .toast-error .toast-icon {
      background: rgba(239, 68, 68, 0.1);
      color: var(--danger);
    }

    .toast-info .toast-icon {
      background: rgba(59, 130, 246, 0.1);
      color: var(--info);
    }

    .toast-body {
      flex: 1;
    }

    .toast-title {
      font-weight: 700;
      color: var(--fg-primary);
      font-size: 0.8rem;
      margin-bottom: var(--space-xs);
    }

    .toast-message {
      color: var(--fg-secondary);
      font-size: 0.75rem;
      line-height: 1.4;
    }

    .toast-close {
      background: transparent;
      border: none;
      color: var(--fg-muted);
      cursor: pointer;
      padding: var(--space-xs);
      border-radius: var(--radius-sm);
      transition: all var(--transition-fast);
      font-size: 18px;
      line-height: 1;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .toast-close:hover {
      background: var(--border-light);
      color: var(--fg-primary);
    }

    @media (max-width: 640px) {
      .toast {
        min-width: auto;
        max-width: none;
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="header-content">
      <h1>ğŸ“š Kindle Review Meter</h1>
    </div>
  </div>

  <div class="main-container">
    <div id="view-settings" class="view active">
      <div class="card">
        <h2>ğŸ–¼ï¸ å…±æœ‰ç”»åƒä½œæˆ</h2>
        
        <div class="form-grid">
          <div class="form-group">
            <label for="amazonUrl">Amazonæ›¸ç±URL</label>
            <div class="input-group">
              <input type="url" id="amazonUrl" placeholder="https://www.amazon.co.jp/dp/...">
              <button type="button" class="btn primary" onclick="app.fetchAmazonData()">
                ğŸ” è‡ªå‹•å–å¾—
              </button>
            </div>
          </div>
          
          <div class="form-group">
            <label for="title">æ›¸ç±ã‚¿ã‚¤ãƒˆãƒ«</label>
            <input type="text" id="title" placeholder="æ›¸ç±ã‚¿ã‚¤ãƒˆãƒ«">
          </div>
          
          <div class="form-group">
            <label for="author">è‘—è€…å</label>
            <input type="text" id="author" placeholder="è‘—è€…å">
          </div>
          
          <div class="form-group">
            <label for="imageUrl">æ›¸å½±URLï¼ˆä»»æ„ï¼‰</label>
            <input type="url" id="imageUrl" placeholder="https://m.media-amazon.com/images/I/...">
          </div>
          
          <div class="form-group">
            <label for="reviewCount">ç¾åœ¨ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼æ•°</label>
            <input type="number" id="reviewCount" min="0" value="0">
          </div>
          
          <div class="form-group">
            <label for="targetReviews">ç›®æ¨™ãƒ¬ãƒ“ãƒ¥ãƒ¼æ•°</label>
            <input type="number" id="targetReviews" min="1" placeholder="ç›®æ¨™å€¤ï¼ˆæ•°å€¤ï¼‰ã‚’è¨­å®šã™ã‚‹ã¨é€²æ—ãƒãƒ¼ãŒå‡ºç¾ã—ã¾ã™">
          </div>
        </div>
        
        <div class="btn-group">
          <button class="btn primary" onclick="app.saveData()">ğŸ’¾ ä¿å­˜</button>
          <button class="btn secondary" onclick="app.clearData()">ğŸ—‘ï¸ ã‚¯ãƒªã‚¢</button>
          <button class="btn primary" onclick="app.exportProgressImage()">ğŸ–¼ï¸ ç”»åƒã‚·ã‚§ã‚¢</button>
        </div>
      </div>
    </div>

    
  </div>

  <!-- Toast Container -->
  <div class="toast-container" id="toast-container"></div>

  <script>
    /**
     * StorageService - ãƒ–ãƒ©ã‚¦ã‚¶ã®LocalStorageã‚’ä½¿ç”¨ã—ãŸãƒ‡ãƒ¼ã‚¿æ°¸ç¶šåŒ–ã‚µãƒ¼ãƒ“ã‚¹
     * 
     * è²¬ä»»ç¯„å›²:
     * - ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã®LocalStorageã¸ã®ä¿å­˜ãƒ»èª­ã¿è¾¼ã¿ãƒ»å‰Šé™¤
     * - JSONå½¢å¼ã§ã®ãƒ‡ãƒ¼ã‚¿ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ãƒ»ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
     * - ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸æ“ä½œæ™‚ã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
     * 
     * ä¸»è¦æ©Ÿèƒ½:
     * - æ›¸ç±æƒ…å ±ï¼ˆã‚¿ã‚¤ãƒˆãƒ«ã€è‘—è€…ã€ç”»åƒURLã€ãƒ¬ãƒ“ãƒ¥ãƒ¼æ•°ã€ç›®æ¨™å€¤ç­‰ï¼‰ã®æ°¸ç¶šåŒ–
     * - ã‚¯ãƒ­ã‚¹ã‚»ãƒƒã‚·ãƒ§ãƒ³ã§ã®ãƒ‡ãƒ¼ã‚¿ä¿æŒ
     * - å®‰å…¨ãªã‚¨ãƒ©ãƒ¼å‡¦ç†ã«ã‚ˆã‚‹å …ç‰¢æ€§ç¢ºä¿
     */
    class StorageService {
      /**
       * StorageServiceã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
       * @param {string} key - LocalStorageã§ä½¿ç”¨ã™ã‚‹ã‚­ãƒ¼åï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 'kindleReviewMeter'ï¼‰
       */
      constructor(key = 'kindleReviewMeter') {
        this.storageKey = key;
      }

      /**
       * ãƒ‡ãƒ¼ã‚¿ã‚’LocalStorageã«ä¿å­˜
       * ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’JSONæ–‡å­—åˆ—ã«å¤‰æ›ã—ã¦ä¿å­˜ã—ã€ã‚¨ãƒ©ãƒ¼æ™‚ã¯å®‰å…¨ã«å¤±æ•—
       * 
       * @param {Object} data - ä¿å­˜ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
       * @param {string} data.title - æ›¸ç±ã‚¿ã‚¤ãƒˆãƒ«
       * @param {string} data.author - è‘—è€…å
       * @param {string} data.imageUrl - æ›¸å½±ã®URL
       * @param {number} data.reviewCount - ç¾åœ¨ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼æ•°
       * @param {number} data.targetReviews - ç›®æ¨™ãƒ¬ãƒ“ãƒ¥ãƒ¼æ•°
       * @param {string} data.amazonUrl - Amazonå•†å“ãƒšãƒ¼ã‚¸URL
       * @returns {boolean} ä¿å­˜æˆåŠŸæ™‚ã¯trueã€å¤±æ•—æ™‚ã¯false
       */
      save(data) {
        try {
          localStorage.setItem(this.storageKey, JSON.stringify(data));
          return true;
        } catch (error) {
          console.error('Storage save failed:', error);
          return false;
        }
      }

      /**
       * LocalStorageã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
       * JSONæ–‡å­—åˆ—ã‚’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã—ã¦è¿”å´ã€ã‚¨ãƒ©ãƒ¼æ™‚ã¯nullã‚’è¿”å´
       * 
       * @returns {Object|null} ä¿å­˜ã•ã‚Œã¦ã„ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€æœªä¿å­˜ã¾ãŸã¯ã‚¨ãƒ©ãƒ¼æ™‚ã¯null
       */
      load() {
        try {
          const data = localStorage.getItem(this.storageKey);
          return data ? JSON.parse(data) : null;
        } catch (error) {
          console.error('Storage load failed:', error);
          return null;
        }
      }

      /**
       * LocalStorageã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤
       * ä¿å­˜ã•ã‚Œã¦ã„ã‚‹å…¨ã¦ã®æ›¸ç±æƒ…å ±ã‚’ã‚¯ãƒªã‚¢
       * 
       * @returns {boolean} å‰Šé™¤æˆåŠŸæ™‚ã¯trueã€å¤±æ•—æ™‚ã¯false
       */
      clear() {
        try {
          localStorage.removeItem(this.storageKey);
          return true;
        } catch (error) {
          console.error('Storage clear failed:', error);
          return false;
        }
      }
    }

    /**
     * ToastService - ãƒ¦ãƒ¼ã‚¶ãƒ¼é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ 
     * 
     * è²¬ä»»ç¯„å›²:
     * - ä¸€æ™‚çš„ãªé€šçŸ¥ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®è¡¨ç¤ºãƒ»ç®¡ç†ãƒ»å‰Šé™¤
     * - é€šçŸ¥ã‚¿ã‚¤ãƒ—åˆ¥ï¼ˆæˆåŠŸ/ã‚¨ãƒ©ãƒ¼/è­¦å‘Š/æƒ…å ±ï¼‰ã®è¦–è¦šçš„å·®åˆ¥åŒ–
     * - ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä»˜ãã®è¡¨ç¤ºãƒ»éè¡¨ç¤ºåˆ¶å¾¡
     * 
     * ä¸»è¦æ©Ÿèƒ½:
     * - å³ä¸Šéš…ã§ã®é€šçŸ¥è¡¨ç¤ºï¼ˆæˆåŠŸã€ã‚¨ãƒ©ãƒ¼ã€è­¦å‘Šã€æƒ…å ±ï¼‰
     * - è‡ªå‹•æ¶ˆæ»…ï¼ˆè¨­å®šå¯èƒ½ãªæ™‚é–“ï¼‰ã¨æ‰‹å‹•ã‚¯ãƒ­ãƒ¼ã‚º
     * - è¤‡æ•°é€šçŸ¥ã®ç©ã¿é‡ã­è¡¨ç¤º
     * - ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£å¯¾å¿œï¼ˆARIA ãƒ©ãƒ™ãƒ«ç­‰ï¼‰
     */
    class ToastService {
      /**
       * ToastServiceã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
       * é€šçŸ¥ã‚³ãƒ³ãƒ†ãƒŠã®å‚ç…§ã¨é€šçŸ¥é…åˆ—ã‚’åˆæœŸåŒ–
       */
      constructor() {
        this.container = null;
        this.toasts = [];
        this.init();
      }

      /**
       * é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã®åˆæœŸåŒ–
       * DOMè¦ç´ ã®å‚ç…§ã‚’å–å¾—ã—ã€é€šçŸ¥è¡¨ç¤ºã®æº–å‚™ã‚’è¡Œã†
       */
      init() {
        this.container = document.getElementById('toast-container');
      }

      /**
       * é€šçŸ¥ã‚’è¡¨ç¤ºã™ã‚‹ãƒ¡ã‚¤ãƒ³é–¢æ•°
       * æŒ‡å®šã•ã‚ŒãŸå†…å®¹ã¨ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã«åŸºã¥ã„ã¦é€šçŸ¥ã‚’ç”Ÿæˆãƒ»è¡¨ç¤º
       * 
       * @param {string} message - è¡¨ç¤ºã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å†…å®¹
       * @param {string} type - é€šçŸ¥ã‚¿ã‚¤ãƒ—ï¼ˆ'success'|'error'|'warning'|'info'ï¼‰
       * @param {Object} options - è¡¨ç¤ºã‚ªãƒ—ã‚·ãƒ§ãƒ³
       * @param {string} options.title - é€šçŸ¥ã®ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆçœç•¥æ™‚ã¯å‹ã«å¿œã˜ãŸæ—¢å®šå€¤ï¼‰
       * @param {number} options.duration - è‡ªå‹•æ¶ˆæ»…ã¾ã§ã®æ™‚é–“ï¼ˆãƒŸãƒªç§’ã€0ã§ç„¡åŠ¹ï¼‰
       * @param {boolean} options.closable - æ‰‹å‹•ã‚¯ãƒ­ãƒ¼ã‚ºãƒœã‚¿ãƒ³ã®è¡¨ç¤ºæœ‰ç„¡
       * @returns {HTMLElement} ä½œæˆã•ã‚ŒãŸé€šçŸ¥è¦ç´ 
       */
      show(message, type = 'info', options = {}) {
        const {
          title = this.getDefaultTitle(type),
          duration = 4000,
          closable = true
        } = options;

        const toast = this.createToast(message, type, title, closable);
        this.container.appendChild(toast);
        
        this.toasts.push(toast);
        
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¡¨ç¤ºã‚’æ¬¡ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã§å®Ÿè¡Œ
        requestAnimationFrame(() => {
          toast.classList.add('show');
        });

        // è‡ªå‹•æ¶ˆæ»…ã®è¨­å®š
        if (duration > 0) {
          setTimeout(() => {
            this.dismiss(toast);
          }, duration);
        }

        return toast;
      }

      /**
       * é€šçŸ¥è¦ç´ ã®DOMæ§‹é€ ã‚’ä½œæˆ
       * ã‚¢ã‚¤ã‚³ãƒ³ã€ã‚¿ã‚¤ãƒˆãƒ«ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã€ã‚¯ãƒ­ãƒ¼ã‚ºãƒœã‚¿ãƒ³ã‚’å«ã‚€å®Œå…¨ãªé€šçŸ¥è¦ç´ ã‚’ç”Ÿæˆ
       * 
       * @param {string} message - ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å†…å®¹
       * @param {string} type - é€šçŸ¥ã‚¿ã‚¤ãƒ—
       * @param {string} title - ã‚¿ã‚¤ãƒˆãƒ«
       * @param {boolean} closable - ã‚¯ãƒ­ãƒ¼ã‚ºãƒœã‚¿ãƒ³ã®è¡¨ç¤ºæœ‰ç„¡
       * @returns {HTMLElement} ä½œæˆã•ã‚ŒãŸé€šçŸ¥DOMè¦ç´ 
       */
      createToast(message, type, title, closable) {
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;

        const icon = this.getIcon(type);
        
        toast.innerHTML = `
          <div class="toast-content">
            <div class="toast-icon">${icon}</div>
            <div class="toast-body">
              <div class="toast-title">${title}</div>
              <div class="toast-message">${message}</div>
            </div>
            ${closable ? '<button class="toast-close" aria-label="Close">Ã—</button>' : ''}
          </div>
        `;

        // ã‚¯ãƒ­ãƒ¼ã‚ºãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
        if (closable) {
          const closeBtn = toast.querySelector('.toast-close');
          closeBtn.addEventListener('click', () => this.dismiss(toast));
        }

        return toast;
      }

      /**
       * é€šçŸ¥ã‚’å‰Šé™¤ã™ã‚‹
       * ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä»˜ãã§é€šçŸ¥ã‚’éè¡¨ç¤ºã«ã—ã€DOM ã‹ã‚‰å®Œå…¨ã«å‰Šé™¤
       * 
       * @param {HTMLElement} toast - å‰Šé™¤å¯¾è±¡ã®é€šçŸ¥è¦ç´ 
       */
      dismiss(toast) {
        if (!toast || !toast.parentNode) return;

        // ç®¡ç†é…åˆ—ã‹ã‚‰å‰Šé™¤
        const index = this.toasts.indexOf(toast);
        if (index > -1) {
          this.toasts.splice(index, 1);
        }

        // å‰Šé™¤ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
        toast.classList.add('removing');
        
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†å¾Œã«DOM ã‹ã‚‰å‰Šé™¤
        setTimeout(() => {
          if (toast.parentNode) {
            toast.parentNode.removeChild(toast);
          }
        }, 300);
      }

      /**
       * é€šçŸ¥ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¿ã‚¤ãƒˆãƒ«ã‚’å–å¾—
       * @param {string} type - é€šçŸ¥ã‚¿ã‚¤ãƒ—
       * @returns {string} ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¿ã‚¤ãƒˆãƒ«
       */
      getDefaultTitle(type) {
        const titles = {
          success: 'æˆåŠŸ',
          error: 'ã‚¨ãƒ©ãƒ¼',
          warning: 'è­¦å‘Š',
          info: 'æƒ…å ±'
        };
        return titles[type] || 'é€šçŸ¥';
      }

      /**
       * é€šçŸ¥ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸã‚¢ã‚¤ã‚³ãƒ³ã‚’å–å¾—
       * @param {string} type - é€šçŸ¥ã‚¿ã‚¤ãƒ—
       * @returns {string} å¯¾å¿œã™ã‚‹ã‚¢ã‚¤ã‚³ãƒ³æ–‡å­—
       */
      getIcon(type) {
        const icons = {
          success: 'âœ“',
          error: 'âœ•',
          warning: 'âš ',
          info: 'â„¹'
        };
        return icons[type] || 'â„¹';
      }

      /**
       * æˆåŠŸé€šçŸ¥ã®è¡¨ç¤ºã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
       * @param {string} message - ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å†…å®¹
       * @param {Object} options - è¡¨ç¤ºã‚ªãƒ—ã‚·ãƒ§ãƒ³
       * @returns {HTMLElement} ä½œæˆã•ã‚ŒãŸé€šçŸ¥è¦ç´ 
       */
      success(message, options = {}) {
        return this.show(message, 'success', options);
      }

      /**
       * ã‚¨ãƒ©ãƒ¼é€šçŸ¥ã®è¡¨ç¤ºã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
       * @param {string} message - ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å†…å®¹
       * @param {Object} options - è¡¨ç¤ºã‚ªãƒ—ã‚·ãƒ§ãƒ³
       * @returns {HTMLElement} ä½œæˆã•ã‚ŒãŸé€šçŸ¥è¦ç´ 
       */
      error(message, options = {}) {
        return this.show(message, 'error', options);
      }

      /**
       * è­¦å‘Šé€šçŸ¥ã®è¡¨ç¤ºã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
       * @param {string} message - ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å†…å®¹
       * @param {Object} options - è¡¨ç¤ºã‚ªãƒ—ã‚·ãƒ§ãƒ³
       * @returns {HTMLElement} ä½œæˆã•ã‚ŒãŸé€šçŸ¥è¦ç´ 
       */
      warning(message, options = {}) {
        return this.show(message, 'warning', options);
      }

      /**
       * æƒ…å ±é€šçŸ¥ã®è¡¨ç¤ºã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
       * @param {string} message - ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å†…å®¹
       * @param {Object} options - è¡¨ç¤ºã‚ªãƒ—ã‚·ãƒ§ãƒ³
       * @returns {HTMLElement} ä½œæˆã•ã‚ŒãŸé€šçŸ¥è¦ç´ 
       */
      info(message, options = {}) {
        return this.show(message, 'info', options);
      }
    }

    /**
     * App - Kindle Review Meterã®ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚¯ãƒ©ã‚¹
     * 
     * è²¬ä»»ç¯„å›²:
     * - ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å…¨ä½“ã®åˆæœŸåŒ–ã¨åˆ¶å¾¡
     * - Amazonæ›¸ç±ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ãƒ»å‡¦ç†ãƒ»è¡¨ç¤º
     * - ç”»åƒã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ©Ÿèƒ½ï¼ˆCanvasæç”»ï¼‰
     * - UIç®¡ç†ï¼ˆã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆã€ãƒ•ã‚©ãƒ¼ãƒ æ“ä½œã€é€²æ—è¡¨ç¤ºï¼‰
     * - ãƒ‡ãƒ¼ã‚¿æ°¸ç¶šåŒ–ã¨Toasté€šçŸ¥ã®çµ±åˆ
     * 
     * ä¸»è¦æ©Ÿèƒ½:
     * - Amazonå•†å“ãƒšãƒ¼ã‚¸ã‹ã‚‰æ›¸ç±æƒ…å ±ã‚’è‡ªå‹•å–å¾—
     * - ãƒ¬ãƒ“ãƒ¥ãƒ¼é€²æ—ã®è¦–è¦šåŒ–ï¼ˆãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã€çµ±è¨ˆè¡¨ç¤ºï¼‰
     * - X/TwitteræŠ•ç¨¿ç”¨ã®ç”»åƒç”Ÿæˆãƒ»ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
     * - è¤‡æ•°ã®CORSãƒ—ãƒ­ã‚­ã‚·ã‚’ä½¿ã£ãŸå …ç‰¢ãªãƒ‡ãƒ¼ã‚¿å–å¾—
     * - æ—¥æœ¬èªãƒ†ã‚­ã‚¹ãƒˆã«å¯¾å¿œã—ãŸæ”¹è¡Œå‡¦ç†
     */
    class App {
      /**
       * Appã‚¯ãƒ©ã‚¹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
       * å¿…è¦ãªã‚µãƒ¼ãƒ“ã‚¹ï¼ˆStorage, Toastï¼‰ã‚’åˆæœŸåŒ–ã—ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’èµ·å‹•
       */
      constructor() {
        this.storage = new StorageService();
        this.toast = new ToastService();
        this.currentTab = 'settings';
        this.init();
      }

      /**
       * ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®åˆæœŸåŒ–
       * ã‚¤ãƒ™ãƒ³ãƒˆãƒã‚¤ãƒ³ãƒ‰ã€ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã€ã‚¦ã‚§ãƒ«ã‚«ãƒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®è¡¨ç¤ºã‚’è¡Œã†
       */
      init() {
        this.bindEvents();
        this.loadData();
        
        // ã‚¦ã‚§ãƒ«ã‚«ãƒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é…å»¶è¡¨ç¤º
        setTimeout(() => {
          this.toast.info('å®Œå…¨ç‰ˆKindle Review Meter ã¸ã‚ˆã†ã“ãï¼', {
            title: 'ã‚ˆã†ã“ã',
            duration: 6000
          });
        }, 800);
      }

      /**
       * DOMè¦ç´ ã¸ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
       * ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆãªã©ã®UIæ“ä½œã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™»éŒ²
       */
      bindEvents() {
        document.querySelectorAll('.tab').forEach(tab => {
          tab.addEventListener('click', (e) => {
            this.switchTab(e.target.dataset.tab);
          });
        });
      }

      /**
       * ã‚¿ãƒ–ã®åˆ‡ã‚Šæ›¿ãˆå‡¦ç†
       * ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¿ãƒ–ã¨ãƒ“ãƒ¥ãƒ¼ã‚’åˆ‡ã‚Šæ›¿ãˆã€å¿…è¦ã«å¿œã˜ã¦é€²æ—è¡¨ç¤ºã‚’æ›´æ–°
       * 
       * @param {string} tabName - åˆ‡ã‚Šæ›¿ãˆå…ˆã®ã‚¿ãƒ–åï¼ˆ'settings' | 'progress'ï¼‰
       */
      switchTab(tabName) {
        // å…¨ã¦ã®ã‚¿ãƒ–ã¨ãƒ“ãƒ¥ãƒ¼ã‹ã‚‰activeã‚¯ãƒ©ã‚¹ã‚’å‰Šé™¤
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
        
        // æŒ‡å®šã•ã‚ŒãŸã‚¿ãƒ–ã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«è¨­å®š
        document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
        
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœã®ãŸã‚ã€ãƒ“ãƒ¥ãƒ¼ã®è¡¨ç¤ºã‚’é…å»¶
        setTimeout(() => {
          document.getElementById(`view-${tabName}`).classList.add('active');
        }, 100);
        
        this.currentTab = tabName;
        
        // é€²æ—ã‚¿ãƒ–ã®å ´åˆã¯é€²æ—è¡¨ç¤ºã‚’æ›´æ–°
        if (tabName === 'progress') {
          this.showProgress();
        }
      }

      /**
       * Amazonå•†å“ãƒšãƒ¼ã‚¸ã‹ã‚‰æ›¸ç±ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹ãƒ¡ã‚¤ãƒ³é–¢æ•°
       * URLæ¤œè¨¼ã€ãƒ‡ãƒ¼ã‚¿å–å¾—ã€UIæ›´æ–°ã€ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’çµ±åˆçš„ã«å‡¦ç†
       */
      async fetchAmazonData() {
        const urlInput = document.getElementById('amazonUrl');
        const fetchBtn = event?.target;
        const url = urlInput.value.trim();

        // URLå…¥åŠ›ã®æ¤œè¨¼
        if (!url) {
          this.toast.warning('Amazon URLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', {
            title: 'å…¥åŠ›ãŒå¿…è¦ã§ã™'
          });
          this.animateInputError('amazonUrl');
          return;
        }

        if (!this.isValidAmazonUrl(url)) {
          this.toast.error('æœ‰åŠ¹ãªAmazonæ›¸ç±URLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', {
            title: 'URLå½¢å¼ã‚¨ãƒ©ãƒ¼'
          });
          this.animateInputError('amazonUrl');
          return;
        }

        // UIçŠ¶æ…‹ã®æ›´æ–°ï¼ˆãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°é–‹å§‹ï¼‰
        if (fetchBtn) {
          fetchBtn.classList.add('loading');
          fetchBtn.disabled = true;
        }

        try {
          this.toast.info('Amazonå•†å“ãƒšãƒ¼ã‚¸ã‹ã‚‰æƒ…å ±ã‚’å–å¾—ä¸­...', {
            title: 'ãƒ‡ãƒ¼ã‚¿å–å¾—ä¸­',
            duration: 3000
          });

          const bookData = await this.scrapeAmazonData(url);
          
          if (bookData) {
            this.populateBookData(bookData);
            this.toast.success(`ã€Œ${bookData.title}ã€ã®æƒ…å ±ã‚’å–å¾—ã—ã¾ã—ãŸ`, {
              title: 'å–å¾—å®Œäº†',
              duration: 5000
            });
          } else {
            this.toast.warning('æ›¸ç±æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚CORSãƒ—ãƒ­ã‚­ã‚·ãŒåˆ©ç”¨ã§ããªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚', {
              title: 'å–å¾—å¤±æ•—',
              duration: 8000
            });
          }
        } catch (error) {
          console.error('Amazon data fetch error:', error);
          this.toast.error(`å–å¾—ã‚¨ãƒ©ãƒ¼: ${error.message}. é–‹ç™ºè€…ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã§è©³ç´°ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚`, {
            title: 'ã‚¨ãƒ©ãƒ¼',
            duration: 8000
          });
        } finally {
          if (fetchBtn) {
            fetchBtn.classList.remove('loading');
            fetchBtn.disabled = false;
          }
        }
      }

      /**
       * Amazon URLã®å¦¥å½“æ€§ã‚’æ¤œè¨¼
       * URLå½¢å¼ã®æ¤œè¨¼ã¨Amazonå•†å“ãƒšãƒ¼ã‚¸ãƒ‘ã‚¹ã®ç¢ºèªã‚’å®Ÿè¡Œ
       * 
       * @param {string} url - æ¤œè¨¼ã™ã‚‹URLæ–‡å­—åˆ—
       * @returns {boolean} æœ‰åŠ¹ãªAmazon URLã®å ´åˆtrue
       */
      isValidAmazonUrl(url) {
        try {
          const urlObj = new URL(url);
          return urlObj.hostname.includes('amazon') && 
                 (url.includes('/dp/') || url.includes('/product/') || url.includes('/gp/product/'));
        } catch {
          return false;
        }
      }

      /**
       * Amazonå•†å“ãƒšãƒ¼ã‚¸ã‹ã‚‰æ›¸ç±ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°
       * è¤‡æ•°ã®CORSãƒ—ãƒ­ã‚­ã‚·ã‚’é †æ¬¡è©¦è¡Œã—ã€æœ€ã‚‚ä¿¡é ¼æ€§ã®é«˜ã„ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚’å®Ÿç¾
       * 
       * @param {string} url - Amazonå•†å“ãƒšãƒ¼ã‚¸ã®URL
       * @returns {Promise<Object|null>} å–å¾—ã—ãŸæ›¸ç±ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€å¤±æ•—æ™‚ã¯null
       */
      async scrapeAmazonData(url) {
        try {
          // Multiple CORS proxy attempts for reliability
          const proxies = [
            'https://api.allorigins.win/get?url=',
            'https://corsproxy.io/?',
            'https://cors-anywhere.herokuapp.com/'
          ];
          
          let response = null;
          let htmlContent = null;
          
          // Try each proxy until one works
          for (const proxy of proxies) {
            try {
              const proxyUrl = proxy + encodeURIComponent(url);
              console.log(`Trying proxy: ${proxy}`);
              
              const fetchResponse = await fetch(proxyUrl, {
                method: 'GET',
                headers: {
                  'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                  'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                  'Accept-Language': 'ja,en-US;q=0.7,en;q=0.3',
                  'Accept-Encoding': 'gzip, deflate, br'
                }
              });
              
              if (!fetchResponse.ok) {
                throw new Error(`HTTP error! status: ${fetchResponse.status}`);
              }
              
              const data = await fetchResponse.json();
              htmlContent = data.contents || data.response;
              
              if (htmlContent && htmlContent.length > 1000) {
                console.log('Successfully fetched data with proxy:', proxy);
                break;
              }
            } catch (error) {
              console.warn(`Proxy ${proxy} failed:`, error);
              continue;
            }
          }
          
          if (!htmlContent) {
            throw new Error('All proxies failed');
          }
          
          return this.parseAmazonHTML(htmlContent, url);
          
        } catch (error) {
          console.error('Real scraping failed, falling back to enhanced extraction:', error);
          
          // Enhanced fallback - try to extract ASIN and make educated guess
          return this.enhancedAmazonExtraction(url);
        }
      }

      /**
       * Amazonå•†å“ãƒšãƒ¼ã‚¸ã®HTMLã‹ã‚‰ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’è§£æãƒ»æŠ½å‡º
       * ã‚¿ã‚¤ãƒˆãƒ«ã€è‘—è€…ã€ç”»åƒURLã€ãƒ¬ãƒ“ãƒ¥ãƒ¼æ•°ã‚’è¤‡æ•°ã®ã‚»ãƒ¬ã‚¯ã‚¿ã§å …ç‰¢ã«å–å¾—
       * 
       * @param {string} html - Amazonå•†å“ãƒšãƒ¼ã‚¸ã®HTMLæ–‡å­—åˆ—
       * @param {string} url - å…ƒã®Amazonå•†å“ãƒšãƒ¼ã‚¸URLï¼ˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦è¨˜éŒ²ï¼‰
       * @returns {Object} æŠ½å‡ºã—ãŸæ›¸ç±ãƒ‡ãƒ¼ã‚¿
       * @throws {Error} ãƒ‡ãƒ¼ã‚¿æŠ½å‡ºã«å¤±æ•—ã—ãŸå ´åˆ
       */
      parseAmazonHTML(html, url) {
        try {
          // Create a DOM parser to extract data
          const parser = new DOMParser();
          const doc = parser.parseFromString(html, 'text/html');
          
          // Extract title - multiple selectors for reliability
          const titleSelectors = [
            '#productTitle',
            '.product-title',
            '[data-automation-id="title"]',
            'h1.a-size-large',
            'h1 span'
          ];
          
          let title = null;
          for (const selector of titleSelectors) {
            const element = doc.querySelector(selector);
            if (element) {
              title = element.textContent.trim();
              if (title.length > 5) break;
            }
          }
          
          // Extract author - multiple approaches
          const authorSelectors = [
            '.author .contributorNameID',
            '.author a',
            '.by-author a',
            '[data-automation-id="byline"] a',
            '.a-size-base+ .a-size-base .a-link-normal'
          ];
          
          let author = null;
          for (const selector of authorSelectors) {
            const elements = doc.querySelectorAll(selector);
            if (elements.length > 0) {
              author = Array.from(elements)
                .map(el => el.textContent.trim())
                .filter(text => text.length > 2)
                .join(', ');
              if (author.length > 2) break;
            }
          }
          
          // Extract image URL
          const imageSelectors = [
            '#landingImage',
            '.frontImage img',
            '.itemImageBlock img',
            '#imgBlkFront',
            '#ebooksImgBlkFront'
          ];
          
          let imageUrl = null;
          for (const selector of imageSelectors) {
            const element = doc.querySelector(selector);
            if (element) {
              imageUrl = element.src || element.getAttribute('data-src');
              if (imageUrl && imageUrl.includes('amazon')) break;
            }
          }
          
          // Extract review count - multiple patterns
          const reviewSelectors = [
            '[data-hook="total-review-count"]',
            '.cr-widget-ACR .a-size-base',
            '.averageStarRating .a-size-base',
            '.a-link-normal .a-size-base'
          ];
          
          let reviewCount = 0;
          for (const selector of reviewSelectors) {
            const element = doc.querySelector(selector);
            if (element) {
              const text = element.textContent;
              const matches = text.match(/(\d{1,3}(?:,\d{3})*|\d+)/);
              if (matches) {
                reviewCount = parseInt(matches[1].replace(/,/g, ''));
                if (reviewCount > 0) break;
              }
            }
          }
          
          // Validate extracted data
          if (!title || title.length < 5) {
            throw new Error('Could not extract valid title');
          }
          
          return {
            title: title,
            author: author || 'è‘—è€…ä¸æ˜',
            imageUrl: imageUrl,
            currentReviews: reviewCount,
            extractedFrom: url,
            extractionTime: new Date().toISOString()
          };
          
        } catch (error) {
          console.error('HTML parsing failed:', error);
          throw error;
        }
      }

      /**
       * æ‹¡å¼µAmazon ãƒ‡ãƒ¼ã‚¿æŠ½å‡ºï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½ï¼‰
       * ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°å¤±æ•—æ™‚ã«ASINæŠ½å‡ºã¨ãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯æ¨å®šã§æœ€ä½é™ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
       * 
       * @param {string} url - Amazonå•†å“ãƒšãƒ¼ã‚¸ã®URL
       * @returns {Promise<Object|null>} æ¨å®šã—ãŸæ›¸ç±ãƒ‡ãƒ¼ã‚¿ã€å¤±æ•—æ™‚ã¯null
       */
      async enhancedAmazonExtraction(url) {
        // Extract ASIN for potential API calls
        const asinMatch = url.match(/\/(?:dp|product)\/([A-Z0-9]{10})(?:\/|$|\?)/);
        const asin = asinMatch ? asinMatch[1] : null;
        
        if (!asin) {
          throw new Error('Could not extract ASIN from URL');
        }
        
        // Try alternative Amazon endpoints or APIs
        try {
          // Try Amazon's mobile API endpoint (sometimes less restricted)
          const mobileUrl = `https://www.amazon.co.jp/gp/aw/d/${asin}`;
          const response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(mobileUrl)}`);
          
          if (response.ok) {
            const data = await response.json();
            if (data.contents) {
              return this.parseAmazonHTML(data.contents, url);
            }
          }
        } catch (error) {
          console.warn('Enhanced extraction failed:', error);
        }
        
        // Final fallback - return structure for manual input
        throw new Error('Unable to extract book data automatically. Please enter manually.');
      }

      /**
       * å–å¾—ã—ãŸæ›¸ç±ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ•ã‚©ãƒ¼ãƒ è¦ç´ ã«è‡ªå‹•å…¥åŠ›
       * ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœä»˜ãã§å„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«é †æ¬¡ãƒ‡ãƒ¼ã‚¿ã‚’è¨­å®šã—ã€è¦–è¦šçš„ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’æä¾›
       * 
       * @param {Object} bookData - Amazon ã‹ã‚‰å–å¾—ã—ãŸæ›¸ç±ãƒ‡ãƒ¼ã‚¿
       * @param {string} bookData.title - æ›¸ç±ã‚¿ã‚¤ãƒˆãƒ«
       * @param {string} bookData.author - è‘—è€…å
       * @param {string} bookData.imageUrl - æ›¸å½±URL
       * @param {number} bookData.currentReviews - ç¾åœ¨ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼æ•°
       */
      populateBookData(bookData) {
        const fields = [
          { id: 'title', value: bookData.title },
          { id: 'author', value: bookData.author },
          { id: 'imageUrl', value: bookData.imageUrl },
          { id: 'reviewCount', value: bookData.currentReviews || 0 }
        ];

        fields.forEach((field, index) => {
          setTimeout(() => {
            const element = document.getElementById(field.id);
            if (element) {
              element.style.background = 'linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(52, 211, 153, 0.05))';
              element.value = field.value;
              element.classList.add('animate-pulse');
              
              setTimeout(() => {
                element.style.background = '';
                element.classList.remove('animate-pulse');
              }, 500);
            }
          }, index * 200);
        });

        setTimeout(() => {
          this.animateSuccessFlash();
        }, fields.length * 200 + 300);
      }

      /**
       * ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜
       * ãƒ•ã‚©ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œè¨¼ã—ã€LocalStorageã«ä¿å­˜ã€æˆåŠŸ/å¤±æ•—ã®é€šçŸ¥ã‚’è¡¨ç¤º
       */
      saveData() {
        const saveBtn = event?.target;
        if (saveBtn) {
          saveBtn.classList.add('animate-wiggle');
          setTimeout(() => saveBtn.classList.remove('animate-wiggle'), 800);
        }

        const data = {
          amazonUrl: document.getElementById('amazonUrl').value.trim(),
          title: document.getElementById('title').value.trim(),
          author: document.getElementById('author').value.trim(),
          imageUrl: document.getElementById('imageUrl').value.trim(),
          reviewCount: parseInt(document.getElementById('reviewCount').value) || 0,
          targetReviews: parseInt(document.getElementById('targetReviews').value) || 0,
          savedAt: new Date().toISOString()
        };

        if (!data.title) {
          this.animateInputError('title');
          this.toast.error('æ›¸ç±ã‚¿ã‚¤ãƒˆãƒ«ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', {
            title: 'å…¥åŠ›ã‚¨ãƒ©ãƒ¼'
          });
          return;
        }

        // ç›®æ¨™ãƒ¬ãƒ“ãƒ¥ãƒ¼æ•°ã¯ä»»æ„ã€‚æœªå…¥åŠ›ã‚„0ä»¥ä¸‹ã¯ä¿å­˜ã—ã€é€²æ—è¡¨ç¤ºã§ã¯éè¡¨ç¤ºã«ã—ã¾ã™ã€‚

        if (this.storage.save(data)) {
          this.animateSuccessFlash();
          this.toast.success(`ã€Œ${data.title}ã€ã®è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸ`, {
            title: 'ä¿å­˜å®Œäº†',
            duration: 4000
          });
        } else {
          this.toast.error('ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ', {
            title: 'ä¿å­˜ã‚¨ãƒ©ãƒ¼'
          });
        }
      }

      /**
       * ä¿å­˜ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã®å‰Šé™¤
       * ãƒ¦ãƒ¼ã‚¶ãƒ¼ç¢ºèªå¾Œã€LocalStorageã¨ãƒ•ã‚©ãƒ¼ãƒ è¦ç´ ã‚’ã‚¯ãƒªã‚¢
       */
      async clearData() {
        const confirmed = confirm('ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ');

        if (confirmed) {
          if (this.storage.clear()) {
            document.getElementById('amazonUrl').value = '';
            document.getElementById('title').value = '';
            document.getElementById('author').value = '';
            document.getElementById('imageUrl').value = '';
            document.getElementById('reviewCount').value = '0';
            document.getElementById('targetReviews').value = '';
            
            this.toast.success('ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã—ãŸ', {
              title: 'å‰Šé™¤å®Œäº†'
            });
          } else {
            this.toast.error('å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ', {
              title: 'å‰Šé™¤ã‚¨ãƒ©ãƒ¼'
            });
          }
        }
      }

      /**
       * é€²æ—è¡¨ç¤ºç”»é¢ã®æç”»
       * ä¿å­˜ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‹ã‚‰é€²æ—ãƒãƒ¼ã€çµ±è¨ˆæƒ…å ±ã€ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç”Ÿæˆãƒ»è¡¨ç¤º
       */
      showProgress() {
        const data = this.storage.load();
        const content = document.getElementById('progress-content');
        
        if (!data) {
          content.innerHTML = '<p>è¨­å®šã‚¿ãƒ–ã§ãƒ‡ãƒ¼ã‚¿ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚</p>';
          return;
        }

        const current = Number(data.reviewCount) || 0;
        const targetRaw = Number(data.targetReviews);
        const hasTarget = Number.isFinite(targetRaw) && targetRaw > 0;
        const target = hasTarget ? targetRaw : 0;
        const percentage = hasTarget ? Math.min(Math.round((current / target) * 100), 100) : 0;
        const remaining = hasTarget ? Math.max(target - current, 0) : 0;

        console.log('Progress data:', { current, target, percentage, remaining });

        const milestone = percentage >= 100 ? 'ğŸ‰ ç›®æ¨™é”æˆï¼' : 
                         percentage >= 80 ? 'ğŸ”¥ ã‚‚ã†ã™ãé”æˆï¼' :
                         percentage >= 50 ? 'ğŸ“ˆ é †èª¿ã§ã™' : 'ğŸ’ª ãŒã‚“ã°ã‚Šã¾ã—ã‚‡ã†';

        const statsHtml = hasTarget ? `
              <div class=\"progress-stats\">
                <span class=\"target-info\">ç›®æ¨™: ${target} ãƒ¬ãƒ“ãƒ¥ãƒ¼</span>
                <span class=\"remaining-info\">ã‚ã¨ ${remaining} ãƒ¬ãƒ“ãƒ¥ãƒ¼</span>
              </div>
            ` : '';

        const progressSectionHtml = hasTarget ? `
            <div class="progress-section">
              <div class="progress-bar">
                <div class="progress-fill" style="width: ${Math.max(percentage, 2)}%"></div>
                <div class="progress-text">${percentage}%</div>
              </div>
              ${statsHtml}
            </div>
          ` : '';

        content.innerHTML = `
          <div class="progress-display vertical">
            <div class="book-cover-section">
              <div class="book-cover" id="book-cover">
              </div>
            </div>
            
            <div class="book-meta">
              <h4 class="book-title">${data.title || 'ã‚¿ã‚¤ãƒˆãƒ«æœªè¨­å®š'}</h4>
              <p class="book-author">${data.author || 'è‘—è€…æœªè¨­å®š'}</p>
            </div>
            
            <div class="current-reviews-highlight">
              <div class="current-number">${current}</div>
              <div class="current-label">ç¾åœ¨ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼æ•°</div>
            </div>
            
            ${progressSectionHtml}
            
            <div class="milestone">${milestone}</div>
          </div>
        `;

        const bookCoverContainer = content.querySelector('#book-cover');
        if (data.imageUrl && data.imageUrl.trim()) {
          const img = document.createElement('img');
          img.src = data.imageUrl.trim();
          img.alt = data.title || 'æ›¸ç±';
          
          img.onerror = () => {
            bookCoverContainer.innerHTML = `
              <div class="no-image">
                <div style="font-size: 28px; margin-bottom: 8px;">ğŸ“š</div>
                <div>ç”»åƒèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼</div>
              </div>
            `;
          };
          
          bookCoverContainer.appendChild(img);
        } else {
          bookCoverContainer.innerHTML = `
            <div class="no-image">
              <div style="font-size: 28px; margin-bottom: 8px;">ğŸ“š</div>
              <div>ç”»åƒãªã—</div>
            </div>
          `;
        }

        const actionsDiv = document.getElementById('progress-actions');
        if (actionsDiv) {
          actionsDiv.style.display = 'flex';
        }

        if (hasTarget && percentage > 0) {
          this.toast.info(`é€²æ—: ${percentage}% (${current}/${target})`, {
            title: 'é€²æ—ç¢ºèª',
            duration: 3000
          });
        }
      }

      /**
       * ãƒ¬ãƒ“ãƒ¥ãƒ¼æ•°ã®æ›´æ–°ï¼ˆç¾åœ¨ã¯ãƒ‡ãƒ¢ç”¨æ¨¡æ“¬å‡¦ç†ï¼‰
       * å°†æ¥çš„ã«ã¯Amazon APIã‹ã‚‰ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹æƒ³å®š
       */
      async updateReviewCount() {
        const data = this.storage.load();
        if (!data || !data.amazonUrl) {
          this.toast.warning('Amazon URLãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“', {
            title: 'æ›´æ–°å¤±æ•—'
          });
          return;
        }

        const updateBtn = event?.target;
        if (updateBtn) {
          updateBtn.classList.add('loading');
          updateBtn.disabled = true;
        }

        try {
          this.toast.info('æœ€æ–°ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼æ•°ã‚’ç¢ºèªä¸­...', {
            title: 'ãƒ‡ãƒ¼ã‚¿æ›´æ–°ä¸­'
          });

          await new Promise(resolve => setTimeout(resolve, 2000));
          
          const currentCount = data.reviewCount || 0;
          const newCount = Math.max(currentCount, currentCount + Math.floor(Math.random() * 5));
          
          const updatedData = { ...data, reviewCount: newCount };
          this.storage.save(updatedData);
          
          document.getElementById('reviewCount').value = newCount;
          this.showProgress();
          
          this.toast.success(`ãƒ¬ãƒ“ãƒ¥ãƒ¼æ•°ã‚’æ›´æ–°ã—ã¾ã—ãŸ: ${currentCount} â†’ ${newCount}`, {
            title: 'æ›´æ–°å®Œäº†',
            duration: 4000
          });
          
        } catch (error) {
          this.toast.error('æ›´æ–°ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', {
            title: 'æ›´æ–°ã‚¨ãƒ©ãƒ¼'
          });
        } finally {
          if (updateBtn) {
            updateBtn.classList.remove('loading');
            updateBtn.disabled = false;
          }
        }
      }



      /**
       * LocalStorageã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ã€ãƒ•ã‚©ãƒ¼ãƒ è¦ç´ ã«è¨­å®š
       * ã‚¢ãƒ—ãƒªèµ·å‹•æ™‚ã®ãƒ‡ãƒ¼ã‚¿å¾©å…ƒå‡¦ç†
       */
      loadData() {
        const data = this.storage.load();
        if (data) {
          document.getElementById('amazonUrl').value = data.amazonUrl || '';
          document.getElementById('title').value = data.title || '';
          document.getElementById('author').value = data.author || '';
          document.getElementById('imageUrl').value = data.imageUrl || '';
          document.getElementById('reviewCount').value = data.reviewCount || 0;
          document.getElementById('targetReviews').value = data.targetReviews || '';
        }
      }

      /**
       * å…¥åŠ›ã‚¨ãƒ©ãƒ¼æ™‚ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœ
       * æŒ‡å®šã—ãŸå…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã‚¨ãƒ©ãƒ¼ã‚«ãƒ©ãƒ¼ã¨ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é©ç”¨
       * 
       * @param {string} inputId - ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã•ã›ã‚‹å…¥åŠ›è¦ç´ ã®ID
       */
      animateInputError(inputId) {
        const input = document.getElementById(inputId);
        if (input) {
          input.style.borderColor = 'var(--danger)';
          input.classList.add('animate-wiggle');
          setTimeout(() => {
            input.classList.remove('animate-wiggle');
            input.style.borderColor = '';
          }, 800);
        }
      }

      /**
       * æˆåŠŸæ™‚ã®ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœ
       * ã‚«ãƒ¼ãƒ‰å…¨ä½“ã«ç·‘è‰²ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã‚’è¡¨ç¤º
       */
      animateSuccessFlash() {
        const card = document.querySelector('.card');
        if (card) {
          const flash = document.createElement('div');
          flash.style.cssText = `
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(52, 211, 153, 0.1));
            border-radius: inherit;
            animation: fadeInUp 0.6s var(--transition-normal);
            pointer-events: none;
            z-index: 1;
          `;
          card.style.position = 'relative';
          card.appendChild(flash);
          
          setTimeout(() => {
            if (flash.parentNode) {
              flash.parentNode.removeChild(flash);
            }
          }, 600);
        }
      }

      /**
       * é€²æ—æƒ…å ±ã‚’X/Twitterç”¨ã®3:4æ¯”ç‡ç”»åƒã¨ã—ã¦ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
       * Canvas APIã‚’ä½¿ç”¨ã—ã¦ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³èƒŒæ™¯ã€æ›¸å½±ã€ãƒ†ã‚­ã‚¹ãƒˆã€é€²æ—ãƒãƒ¼ã‚’æç”»
       */
      async exportProgressImageNew() {
        const data = this.storage.load();
        if (!data) {
          this.toast.warning('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“', {
            title: 'ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå¤±æ•—'
          });
          return;
        }

        const current = Number(data.reviewCount) || 0;
        const targetRaw = Number(data.targetReviews);
        const hasTarget = Number.isFinite(targetRaw) && targetRaw > 0;
        const target = hasTarget ? targetRaw : 0;
        const percentage = hasTarget ? Math.min(Math.round((current / target) * 100), 100) : 0;
        const remaining = hasTarget ? Math.max(target - current, 0) : 0;

        try {
          this.toast.info('XæŠ•ç¨¿ç”¨ã®ç”»åƒã‚’ç”Ÿæˆä¸­...', {
            title: 'ç”»åƒç”Ÿæˆä¸­',
            duration: 3000
          });

          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          // 3:4 ratio (vertical) for X/Twitter - 420x560px
          canvas.width = 420;
          canvas.height = 560;

          // Beautiful 3-color radial gradient background
          // Create multiple radial gradients for organic, random-looking effect
          
          // Base gradient (diagonal) - softer color palette
          const baseGradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
          baseGradient.addColorStop(0, '#67e8f9'); // æ°´è‰² (cyan-300)
          baseGradient.addColorStop(0.5, '#f9a8d4'); // ãƒ”ãƒ³ã‚¯ (pink-300)
          baseGradient.addColorStop(1, '#a7f3d0'); // è–„ã„é»„ç·‘ (emerald-200)
          ctx.fillStyle = baseGradient;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Overlay radial gradients for depth and randomness
          ctx.globalCompositeOperation = 'overlay';
          
          // First radial overlay (top-left area) - æ°´è‰²ä¸­å¿ƒ
          const radial1 = ctx.createRadialGradient(canvas.width * 0.3, canvas.height * 0.2, 0, canvas.width * 0.3, canvas.height * 0.2, canvas.width * 0.8);
          radial1.addColorStop(0, 'rgba(103, 232, 249, 0.4)'); // æ°´è‰²
          radial1.addColorStop(0.6, 'rgba(167, 243, 208, 0.3)'); // è–„ã„é»„ç·‘
          radial1.addColorStop(1, 'transparent');
          ctx.fillStyle = radial1;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Second radial overlay (bottom-right area) - ãƒ”ãƒ³ã‚¯ä¸­å¿ƒ
          const radial2 = ctx.createRadialGradient(canvas.width * 0.7, canvas.height * 0.8, 0, canvas.width * 0.7, canvas.height * 0.8, canvas.width * 0.6);
          radial2.addColorStop(0, 'rgba(249, 168, 212, 0.5)'); // ãƒ”ãƒ³ã‚¯
          radial2.addColorStop(0.5, 'rgba(103, 232, 249, 0.2)'); // æ°´è‰²
          radial2.addColorStop(1, 'transparent');
          ctx.fillStyle = radial2;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Third radial overlay (center area) - è–„ã„é»„ç·‘ä¸­å¿ƒ
          const radial3 = ctx.createRadialGradient(canvas.width * 0.5, canvas.height * 0.4, 0, canvas.width * 0.5, canvas.height * 0.4, canvas.width * 0.4);
          radial3.addColorStop(0, 'rgba(167, 243, 208, 0.4)'); // è–„ã„é»„ç·‘
          radial3.addColorStop(0.8, 'rgba(249, 168, 212, 0.2)'); // ãƒ”ãƒ³ã‚¯
          radial3.addColorStop(1, 'transparent');
          ctx.fillStyle = radial3;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Reset composite operation for normal drawing
          ctx.globalCompositeOperation = 'source-over';

          // Add subtle background pattern that complements the new softer gradient
          const patternGradient = ctx.createRadialGradient(canvas.width * 0.15, canvas.height * 0.15, 0, canvas.width * 0.15, canvas.height * 0.15, 120);
          patternGradient.addColorStop(0, 'rgba(103, 232, 249, 0.08)'); // æ°´è‰²ãƒ‘ã‚¿ãƒ¼ãƒ³
          patternGradient.addColorStop(1, 'transparent');
          ctx.fillStyle = patternGradient;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          const patternGradient2 = ctx.createRadialGradient(canvas.width * 0.85, canvas.height * 0.85, 0, canvas.width * 0.85, canvas.height * 0.85, 100);
          patternGradient2.addColorStop(0, 'rgba(167, 243, 208, 0.06)'); // è–„ã„é»„ç·‘ãƒ‘ã‚¿ãƒ¼ãƒ³
          patternGradient2.addColorStop(1, 'transparent');
          ctx.fillStyle = patternGradient2;
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Main container (same as progress display)
          const cardX = 15;
          const cardY = 15;
          const cardWidth = canvas.width - 30;
          const cardHeight = canvas.height - 30;
          
          // Main card background (white, rounded, subtle shadow)
          ctx.save();
          ctx.shadowColor = 'rgba(0, 0, 0, 0.12)';
          ctx.shadowBlur = 20;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 8;
          ctx.fillStyle = 'rgba(255, 255, 255, 0.96)';
          this.roundRect(ctx, cardX, cardY, cardWidth, cardHeight, 24);
          ctx.fill();
          ctx.restore();
          // Border similar to UI (--border)
          ctx.strokeStyle = 'rgba(226, 232, 240, 0.8)';
          ctx.lineWidth = 1;
          ctx.stroke();

          // Add small decorative dot (same as web app)
          ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
          ctx.beginPath();
          ctx.arc(cardX + cardWidth - 20, cardY + 20, 6, 0, 2 * Math.PI);
          ctx.fill();

          // Content positioning
          const contentStartY = cardY + 40;

          // Book cover (top center) - slightly smaller to give more space to text
          const coverX = (canvas.width - 130) / 2; // Center horizontally
          const coverY = contentStartY;
          const coverWidth = 130;
          const coverHeight = 195;

          // Try to load and draw book cover image
          if (data.imageUrl && data.imageUrl.trim()) {
            try {
              await this.drawBookCoverOnCanvas(ctx, data.imageUrl.trim(), coverX, coverY, coverWidth, coverHeight);
            } catch (error) {
              console.log('Failed to load book image, using placeholder');
              this.drawBookPlaceholder(ctx, coverX, coverY, coverWidth, coverHeight);
            }
          } else {
            this.drawBookPlaceholder(ctx, coverX, coverY, coverWidth, coverHeight);
          }

          // Book meta (below cover)
          const metaY = coverY + coverHeight + 20;
          const safePad = 40; // increased inner padding for better text space
          const leftBound = cardX + safePad;
          const rightBound = cardX + cardWidth - safePad;
          ctx.textAlign = 'center';

          // Clip text and UI content to an inner safe area of the white card
          ctx.save();
          this.roundRect(ctx, leftBound, cardY + safePad, cardWidth - safePad * 2, cardHeight - safePad * 2, 16);
          ctx.clip();
          
          // Small title with centered wrapping within [leftBound, rightBound]
          ctx.fillStyle = '#1a202c';
          const title = data.title || 'ã‚¿ã‚¤ãƒˆãƒ«æœªè¨­å®š';
          // Dynamic font size based on title length - slightly larger
          const fontSize = title.length > 25 ? 12 : title.length > 20 ? 13 : 15;
          ctx.font = `bold ${fontSize}px -apple-system, BlinkMacSystemFont, sans-serif`;
          const centerX = (leftBound + rightBound) / 2;
          const availableWidth = rightBound - leftBound;
          console.log('Drawing title:', title, 'Available width:', availableWidth, 'Font size:', fontSize);
          const titleLastY = this.wrapTextBoundedCenterImproved(ctx, title, centerX, metaY, leftBound, rightBound, 17);
          
          // Small author (centered, bounded)
          ctx.font = '11px -apple-system, BlinkMacSystemFont, sans-serif';
          ctx.fillStyle = '#4a5568';
          const author = data.author || 'è‘—è€…æœªè¨­å®š';
          const authorY = titleLastY + 21; // ã‚¿ã‚¤ãƒˆãƒ«è¡Œæ•°ã«é€£å‹•
          console.log('Drawing author centered bounded:', author, 'bounds:', leftBound, rightBound, 'at y:', authorY);
          const authorLastY = this.wrapTextBoundedCenterImproved(ctx, author, centerX, authorY, leftBound, rightBound, 14);

          // Current review count (prominent) - with subtle glow
          const currentY = authorLastY + 36; // ã‚¿ã‚¤ãƒˆãƒ«ãƒ»è‘—è€…ã®é«˜ã•ã«å¿œã˜ã¦é…ç½®
          
          ctx.font = 'bold 56px -apple-system, BlinkMacSystemFont, sans-serif';
          const currentGradient = ctx.createLinearGradient(0, currentY, 0, currentY + 56);
          ctx.textAlign = 'center';
          currentGradient.addColorStop(0, '#3b82f6');
          currentGradient.addColorStop(1, '#06b6d4');
          ctx.fillStyle = currentGradient;
          console.log('Drawing current reviews:', current.toString(), 'at position:', canvas.width / 2, currentY);
          // Glow
          ctx.save();
          ctx.textBaseline = 'top';
          ctx.shadowColor = 'rgba(139, 92, 246, 0.45)';
          ctx.shadowBlur = 18;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 0;
          ctx.fillText(current.toString(), canvas.width / 2, currentY);
          ctx.restore();
          // Main text on top for crisp edges
          ctx.save();
          ctx.textBaseline = 'top';
          ctx.fillText(current.toString(), canvas.width / 2, currentY);
          ctx.restore();

          // "ç¾åœ¨ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼æ•°" label
          ctx.font = 'bold 14px -apple-system, BlinkMacSystemFont, sans-serif';
          ctx.fillStyle = '#4a5568';
          console.log('Drawing current label at position:', canvas.width / 2, currentY + 56 + 8);
          ctx.fillText('ç¾åœ¨ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼æ•°', canvas.width / 2, currentY + 56 + 8);

          // Progress bar and stats only when target is set
          if (hasTarget) {
            // Progress bar (prominent)
            const progressBarY = currentY + 56 + 28;
            const progressBarWidth = cardWidth - 60;
            const progressBarHeight = 24;
            const progressBarX = (canvas.width - progressBarWidth) / 2;

            // Progress bar background with rounded ends
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            const borderRadius = progressBarHeight / 2; // Full rounded ends
            this.roundRect(ctx, progressBarX, progressBarY, progressBarWidth, progressBarHeight, borderRadius);
            ctx.fill();
            ctx.stroke();

            // Progress bar fill (match UI gradient) with properly rounded ends
            if (percentage > 0) {
              const fillWidth = Math.max((progressBarWidth * percentage) / 100, borderRadius * 2);
              
              // ãƒ†ã‚¹ãƒˆç”¨ï¼šã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã®ä»£ã‚ã‚Šã«å˜è‰²ã‚’ä½¿ç”¨
              ctx.fillStyle = '#3b82f6'; // å˜è‰²ãƒ–ãƒ«ãƒ¼ã§ãƒ†ã‚¹ãƒˆ
              
              // const progressGradient = ctx.createLinearGradient(progressBarX, progressBarY, progressBarX + progressBarWidth, progressBarY + progressBarHeight);
              // progressGradient.addColorStop(0.0, '#3b82f6');
              // progressGradient.addColorStop(0.6, '#06b6d4');
              // progressGradient.addColorStop(1.0, '#10b981');
              // ctx.fillStyle = progressGradient;
              
              console.log('Drawing progress:', { percentage, fillWidth, borderRadius, progressBarWidth, progressBarHeight });
              
              // å®Œå…¨ã«ä¸¸è§’ã®é€²æ—ãƒãƒ¼ã‚’æç”» - æœ€é©åŒ–ç‰ˆ
              if (percentage >= 100) {
                // 100%ã®å ´åˆï¼šroundRecté–¢æ•°ã‚’ä½¿ç”¨
                this.roundRect(ctx, progressBarX, progressBarY, progressBarWidth, progressBarHeight, borderRadius);
                ctx.fill();
              } else {
                // 100%æœªæº€ï¼šå·¦ç«¯ä¸¸è§’ç¢ºä¿ + å³ç«¯ã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°
                ctx.save();
                
                // å·¦ç«¯ã®ä¸¸ã¿ã‚’ç¢ºå®Ÿã«å«ã‚€ã‚ˆã†ã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°é ˜åŸŸã‚’èª¿æ•´
                // å·¦ç«¯ã¯å°‘ã—å·¦ã«ã€å³ç«¯ã¯é€²æ—ä½ç½®ã¾ã§
                const clipX = progressBarX - 1; // å·¦ç«¯ã®ä¸¸ã¿ã‚’å®Œå…¨ã«å«ã‚ã‚‹
                const clipWidth = fillWidth + 1; // å³ç«¯ã¾ã§æ­£ç¢ºã«
                
                ctx.beginPath();
                ctx.rect(clipX, progressBarY, clipWidth, progressBarHeight);
                ctx.clip();
                
                // ä¸¸è§’çŸ©å½¢ã‚’æç”»ï¼ˆä¸¡ç«¯ã®ä¸¸è§’ãŒç¢ºå®Ÿã«è¦‹ãˆã‚‹ï¼‰
                this.roundRect(ctx, progressBarX, progressBarY, Math.max(fillWidth, borderRadius * 2), progressBarHeight, borderRadius);
                ctx.fill();
                
                console.log('Clipping adjustment - clipX:', clipX, 'clipWidth:', clipWidth, 'original fillWidth:', fillWidth);
                
                ctx.restore();
                
                // ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°
                console.log('Clipped rounded progress - fillWidth:', fillWidth, 'borderRadius:', borderRadius);
              }
            }

            // Progress percentage (improved visibility)
            ctx.font = 'bold 14px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = '#1a202c';
            ctx.textAlign = 'center';
            console.log('Drawing progress percentage:', `${percentage}%`, 'at position:', canvas.width / 2, progressBarY + 17);
            ctx.fillText(`${percentage}%`, canvas.width / 2, progressBarY + 17);

            // Stats section - only if target specified (add more spacing)
            const statsY = progressBarY + 40;
            const cardWidth1 = (cardWidth - 80) / 2;
            const cardHeight1 = 28;
            const gap = 10;

            // Target card (emphasized border and fill)
            const targetCardX = cardX + 30;
            ctx.save();
            ctx.shadowColor = 'rgba(0, 0, 0, 0.08)';
            ctx.shadowBlur = 12;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 4;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            this.roundRect(ctx, targetCardX, statsY, cardWidth1, cardHeight1, 8);
            ctx.fill();
            ctx.restore();
            ctx.strokeStyle = 'rgba(226, 232, 240, 1)';
            ctx.lineWidth = 1;
            this.roundRect(ctx, targetCardX, statsY, cardWidth1, cardHeight1, 8);
            ctx.stroke();
            ctx.font = '10px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = '#1f2937';
            ctx.textAlign = 'center';
            ctx.fillText(`ç›®æ¨™: ${target} ãƒ¬ãƒ“ãƒ¥ãƒ¼`, targetCardX + cardWidth1/2, statsY + cardHeight1/2 + 3);

            // Remaining card (emphasized)
            const remainingCardX = targetCardX + cardWidth1 + gap;
            ctx.save();
            ctx.shadowColor = 'rgba(0, 0, 0, 0.08)';
            ctx.shadowBlur = 12;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 4;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            this.roundRect(ctx, remainingCardX, statsY, cardWidth1, cardHeight1, 8);
            ctx.fill();
            ctx.restore();
            ctx.strokeStyle = 'rgba(226, 232, 240, 1)';
            ctx.lineWidth = 1;
            this.roundRect(ctx, remainingCardX, statsY, cardWidth1, cardHeight1, 8);
            ctx.stroke();
            ctx.fillStyle = '#1f2937';
            ctx.fillText(`ã‚ã¨ ${remaining} ãƒ¬ãƒ“ãƒ¥ãƒ¼`, remainingCardX + cardWidth1/2, statsY + cardHeight1/2 + 3);
          }

          // (Removed) milestone and branding to maximize content space

          // Restore to remove clip (if any content later needs to overflow)
          ctx.restore();

          // Convert to blob and download
          canvas.toBlob((blob) => {
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `kindle-review-progress-${current}-${target}-${Date.now()}.png`;
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            URL.revokeObjectURL(url);
            
            this.toast.success('XæŠ•ç¨¿ç”¨ç”»åƒã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸï¼', {
              title: 'ç”»åƒã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Œäº†',
              duration: 5000
            });
          }, 'image/png');

        } catch (error) {
          console.error('Image export failed:', error);
          this.toast.error('ç”»åƒã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ', {
            title: 'ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼'
          });
        }
      }

      // å¤ã„é–¢æ•°ã‚’å®Œå…¨ã«å‰Šé™¤ã—ã¦æ–°ã—ã„é–¢æ•°ã‚’è¿½åŠ 
      async exportProgressImage() {
        console.log('NEW EXPORT FUNCTION CALLED!');
        return this.exportProgressImageNew();
      }

      async drawBookCoverOnCanvas(ctx, imageUrl, x, y, width, height) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => {
            // Save state before clipping/shadow
            ctx.save();

            // Draw shadow + clipped image
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 8;

            this.roundRect(ctx, x, y, width, height, 16);
            ctx.clip();
            ctx.drawImage(img, x, y, width, height);

            // Restore to clear clip/shadow
            ctx.restore();

            // Draw border on a clean state
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 3;
            this.roundRect(ctx, x, y, width, height, 16);
            ctx.stroke();
            ctx.restore();

            resolve();
          };
          img.onerror = reject;
          img.src = imageUrl;
        });
      }

      /**
       * æ›¸å½±ç”¨ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã®æç”»
       * æ›¸å½±ãŒå­˜åœ¨ã—ãªã„å ´åˆã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¡¨ç¤ºï¼ˆã‚·ãƒ£ãƒ‰ã‚¦ã€ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã€ã‚¢ã‚¤ã‚³ãƒ³ï¼‰
       * 
       * @param {CanvasRenderingContext2D} ctx - Canvasæç”»ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
       * @param {number} x - æç”»é–‹å§‹Xåº§æ¨™
       * @param {number} y - æç”»é–‹å§‹Yåº§æ¨™  
       * @param {number} width - ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã®å¹…
       * @param {number} height - ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã®é«˜ã•
       */
      drawBookPlaceholder(ctx, x, y, width, height) {
        // Shadow
        ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
        ctx.shadowBlur = 15;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 8;

        // Background
        const gradient = ctx.createLinearGradient(x, y, x, y + height);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0.05)');
        ctx.fillStyle = gradient;
        this.roundRect(ctx, x, y, width, height, 16);
        ctx.fill();

        // Reset shadow
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;

        // Border
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 2;
        this.roundRect(ctx, x, y, width, height, 16);
        ctx.stroke();

        // Book icon
        ctx.font = '48px Inter, system-ui';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.textAlign = 'center';
        ctx.fillText('ğŸ“š', x + width / 2, y + height / 2 + 10);

        // "ç”»åƒãªã—" text
        ctx.font = '12px Inter, system-ui';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.fillText('ç”»åƒãªã—', x + width / 2, y + height / 2 + 35);
      }


      /**
       * ãƒ†ã‚­ã‚¹ãƒˆè‡ªå‹•æŠ˜ã‚Šè¿”ã—æ©Ÿèƒ½ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ç‰ˆï¼‰
       * æŒ‡å®šå¹…ã§ãƒ†ã‚­ã‚¹ãƒˆã‚’æŠ˜ã‚Šè¿”ã—ã€æ—¥æœ¬èªï¼ˆã‚¹ãƒšãƒ¼ã‚¹ãªã—ï¼‰ã«å¯¾å¿œ
       * 
       * @param {CanvasRenderingContext2D} ctx - Canvasæç”»ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
       * @param {string} text - æŠ˜ã‚Šè¿”ã—ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
       * @param {number} x - æç”»é–‹å§‹Xåº§æ¨™
       * @param {number} y - æç”»é–‹å§‹Yåº§æ¨™
       * @param {number} maxWidth - æœ€å¤§å¹…
       * @param {number} lineHeight - è¡Œé–“
       * @returns {number} æœ€å¾Œã«æç”»ã—ãŸè¡Œã®Yåº§æ¨™
       */
      wrapText(ctx, text, x, y, maxWidth, lineHeight) {
        // Support languages without spaces (e.g., Japanese)
        const hasSpace = text.includes(' ');
        const tokens = hasSpace ? text.split(' ') : Array.from(text);
        let line = '';
        for (let i = 0; i < tokens.length; i++) {
          const sep = hasSpace ? ' ' : '';
          const testLine = line + tokens[i] + sep;
          const testWidth = ctx.measureText(testLine).width;
          if (testWidth > maxWidth && line) {
            ctx.fillText(line, x, y);
            line = tokens[i] + sep;
            y += lineHeight;
          } else {
            line = testLine;
          }
        }
        if (line) ctx.fillText(line, x, y);
        return y; // return baseline of last drawn line
      }

      /**
       * å·¦å¯„ã›ãƒ†ã‚­ã‚¹ãƒˆæŠ˜ã‚Šè¿”ã—ï¼ˆå¢ƒç•ŒæŒ‡å®šç‰ˆï¼‰
       * æŒ‡å®šã—ãŸå·¦å³ã®ç¯„å›²å†…ã§ãƒ†ã‚­ã‚¹ãƒˆã‚’å·¦å¯„ã›ã§æŠ˜ã‚Šè¿”ã—
       * 
       * @param {CanvasRenderingContext2D} ctx - Canvasæç”»ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
       * @param {string} text - æŠ˜ã‚Šè¿”ã—ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
       * @param {number} left - å·¦ç«¯ä½ç½®
       * @param {number} top - ä¸Šç«¯ä½ç½®
       * @param {number} right - å³ç«¯ä½ç½®
       * @param {number} lineHeight - è¡Œé–“
       * @returns {number} æœ€å¾Œã«æç”»ã—ãŸè¡Œã®Yåº§æ¨™
       */
      wrapTextBounded(ctx, text, left, top, right, lineHeight) {
        const maxWidth = Math.max(0, right - left);
        const originalAlign = ctx.textAlign;
        ctx.textAlign = 'left';
        const hasSpace = text.includes(' ');
        const tokens = hasSpace ? text.split(' ') : Array.from(text);
        let line = '';
        let y = top;
        for (let i = 0; i < tokens.length; i++) {
          const sep = hasSpace ? ' ' : '';
          const test = line + tokens[i] + sep;
          const w = ctx.measureText(test).width;
          if (w > maxWidth && line) {
            ctx.fillText(line, left, y);
            line = tokens[i] + sep;
            y += lineHeight;
          } else {
            line = test;
          }
        }
        if (line) ctx.fillText(line, left, y);
        ctx.textAlign = originalAlign;
        return y;
      }

      /**
       * ä¸­å¤®å¯„ã›ãƒ†ã‚­ã‚¹ãƒˆæŠ˜ã‚Šè¿”ã—ï¼ˆå¢ƒç•ŒæŒ‡å®šç‰ˆï¼‰
       * æŒ‡å®šã—ãŸå·¦å³ã®ç¯„å›²å†…ã§ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¸­å¤®å¯„ã›ã§æŠ˜ã‚Šè¿”ã—
       * 
       * @param {CanvasRenderingContext2D} ctx - Canvasæç”»ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
       * @param {string} text - æŠ˜ã‚Šè¿”ã—ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆ  
       * @param {number} centerX - ä¸­å¿ƒXåº§æ¨™
       * @param {number} top - ä¸Šç«¯ä½ç½®
       * @param {number} left - å·¦ç«¯ä½ç½®
       * @param {number} right - å³ç«¯ä½ç½®
       * @param {number} lineHeight - è¡Œé–“
       * @returns {number} æœ€å¾Œã®è¡Œã®ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³
       */
      wrapTextBoundedCenter(ctx, text, centerX, top, left, right, lineHeight) {
        const maxWidth = Math.max(0, right - left);
        const originalAlign = ctx.textAlign;
        ctx.textAlign = 'center';
        const hasSpace = text.includes(' ');
        const tokens = hasSpace ? text.split(' ') : Array.from(text);
        const lines = [];
        let line = '';
        for (let i = 0; i < tokens.length; i++) {
          const sep = hasSpace ? ' ' : '';
          const test = line + tokens[i] + sep;
          const w = ctx.measureText(test).width;
          if (w > maxWidth && line) {
            lines.push(line.trimEnd());
            line = tokens[i] + sep;
          } else {
            line = test;
          }
        }
        if (line) lines.push(line.trimEnd());
        let y = top;
        for (const l of lines) {
          ctx.fillText(l, centerX, y);
          y += lineHeight;
        }
        ctx.textAlign = originalAlign;
        return y - lineHeight; // return last line baseline
      }

      /**
       * é€²åŒ–ç‰ˆä¸­å¤®å¯„ã›ãƒ†ã‚­ã‚¹ãƒˆæŠ˜ã‚Šè¿”ã—
       * æ—¥æœ¬èªãƒ†ã‚­ã‚¹ãƒˆã«ç‰¹åŒ–ã—ã€æ–‡å­—ãƒ¬ãƒ™ãƒ«ã§ã®é©åˆ‡ãªæŠ˜ã‚Šè¿”ã—ã‚’å®Ÿç¾
       * 
       * @param {CanvasRenderingContext2D} ctx - Canvasæç”»ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
       * @param {string} text - æŠ˜ã‚Šè¿”ã—ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
       * @param {number} centerX - ä¸­å¿ƒXåº§æ¨™
       * @param {number} top - ä¸Šç«¯ä½ç½®
       * @param {number} left - å·¦ç«¯ä½ç½®
       * @param {number} right - å³ç«¯ä½ç½®
       * @param {number} lineHeight - è¡Œé–“
       * @returns {number} æœ€å¾Œã®è¡Œã®ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³
       */
      wrapTextBoundedCenterImproved(ctx, text, centerX, top, left, right, lineHeight) {
        const maxWidth = Math.max(0, right - left) * 0.75; // Use 75% to force more line breaks
        const originalAlign = ctx.textAlign;
        ctx.textAlign = 'center';
        
        console.log('wrapTextBoundedCenterImproved:', text, 'Available space:', (right - left), 'maxWidth:', maxWidth);
        
        const lines = [];
        let line = '';
        
        // Character-level breaking with smart break points
        for (let i = 0; i < text.length; i++) {
          const char = text[i];
          const testLine = line + char;
          const testWidth = ctx.measureText(testLine).width;
          
          console.log(`Testing char "${char}": line="${line}" -> testLine="${testLine}", width=${testWidth}, max=${maxWidth}`);
          
          // Check if we need to break
          if (testWidth > maxWidth && line.length > 0) {
            // Try to find a better break point in the current line
            const breakChars = ['ã€', 'ï¼‰', 'ã€', 'ã€‚', ' ', '/', '(', 'ï¼ˆ'];
            let bestBreakPos = -1;
            
            // Look for good break points from the end of the line
            for (let j = line.length - 1; j >= Math.max(0, line.length - 5); j--) {
              if (breakChars.includes(line[j])) {
                bestBreakPos = j + 1;
                break;
              }
            }
            
            if (bestBreakPos > 0 && bestBreakPos < line.length) {
              // Break at the good position
              const beforeBreak = line.substring(0, bestBreakPos);
              const afterBreak = line.substring(bestBreakPos);
              console.log(`Smart breaking: "${beforeBreak}" | "${afterBreak}"`);
              lines.push(beforeBreak);
              line = afterBreak + char;
            } else {
              // No good break point, just break here
              console.log(`Breaking line: "${line}" (width: ${ctx.measureText(line).width})`);
              lines.push(line);
              line = char;
            }
          } else {
            line = testLine;
          }
        }
        
        // Add the last line if it exists
        if (line) {
          console.log(`Final line: "${line}" (width: ${ctx.measureText(line).width})`);
          lines.push(line);
        }
        
        console.log('Generated lines:', lines);
        
        let y = top;
        for (const l of lines) {
          console.log('Drawing line:', l, 'at:', centerX, y);
          ctx.fillText(l, centerX, y);
          y += lineHeight;
        }
        
        ctx.textAlign = originalAlign;
        return y - lineHeight; // return last line baseline
      }

      /**
       * è§’ä¸¸å››è§’å½¢æç”»ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
       * arcTo API ã‚’ä½¿ç”¨ã—ã¦ã€é©åˆ‡ãªåŠå¾„èª¿æ•´ã¨æ»‘ã‚‰ã‹ãªè§’ä¸¸ã‚’å®Ÿç¾
       * 
       * @param {CanvasRenderingContext2D} ctx - Canvasæç”»ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
       * @param {number} x - æç”»é–‹å§‹Xåº§æ¨™
       * @param {number} y - æç”»é–‹å§‹Yåº§æ¨™
       * @param {number} width - å››è§’å½¢ã®å¹…
       * @param {number} height - å››è§’å½¢ã®é«˜ã•
       * @param {number} radius - è§’ã®åŠå¾„
       */
      roundRect(ctx, x, y, width, height, radius) {
        // åŠå¾„ãŒå¤§ãã™ãã‚‹å ´åˆã®èª¿æ•´
        const maxRadius = Math.min(width / 2, height / 2);
        const r = Math.min(radius, maxRadius);
        
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + width, y, x + width, y + height, r);
        ctx.arcTo(x + width, y + height, x, y + height, r);
        ctx.arcTo(x, y + height, x, y, r);
        ctx.arcTo(x, y, x + width, y, r);
        ctx.closePath();
      }
    }

    // Create global app instance
    window.app = new App();
  </script>
</body>
</html>
